/**
 * CROSS-ORIGIN RESOURCE TIMING ATTACK BUG FIX: Comprehensive cross-origin security protection
 * 
 * This module provides protection against:
 * - Cross-origin resource timing attacks
 * - CORS bypass attempts
 * - Cross-origin information leakage
 * - Timing-based side-channel attacks via network requests
 * - DNS timing attacks
 */

export interface CrossOriginThreat {
  type: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  origin: string;
  timestamp: number;
  blocked: boolean;
}

export interface ResourceTimingEntry {
  name: string;
  startTime: number;
  duration: number;
  transferSize: number;
  origin: string;
  suspicious: boolean;
}

export interface CORSConfiguration {
  allowedOrigins: string[];
  allowedMethods: string[];
  allowedHeaders: string[];
  maxAge: number;
  credentials: boolean;
  enableResourceTimingProtection: boolean;
  enableTimingJitter: boolean;
}

/**
 * CROSS-ORIGIN RESOURCE TIMING ATTACK BUG FIX: Main protection class
 */
export class CrossOriginProtection {
  private static instance: CrossOriginProtection;
  private config: CORSConfiguration;
  private threats: CrossOriginThreat[] = [];
  private resourceTimings: ResourceTimingEntry[] = [];
  private originalFetch: typeof fetch;
  private originalXMLHttpRequest: typeof XMLHttpRequest;
  private timingObfuscationMap: Map<string, number> = new Map();
  private originValidationCache: Map<string, { valid: boolean; timestamp: number }> = new Map();
  
  private readonly DEFAULT_CONFIG: CORSConfiguration = {
    allowedOrigins: ['http://localhost:3000', 'http://localhost:5173', 'http://127.0.0.1:3000'],
    allowedMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'],
    maxAge: 86400, // 24 hours
    credentials: true,
    enableResourceTimingProtection: true,
    enableTimingJitter: true
  };
  
  static getInstance(config?: Partial<CORSConfiguration>): CrossOriginProtection {
    if (!this.instance) {
      this.instance = new CrossOriginProtection(config);
    }
    return this.instance;
  }
  
  private constructor(config?: Partial<CORSConfiguration>) {
    this.config = { ...this.DEFAULT_CONFIG, ...config };
    this.initializeProtection();
  }
  
  /**
   * CROSS-ORIGIN RESOURCE TIMING ATTACK BUG FIX: Initialize comprehensive protection
   */
  private initializeProtection(): void {
    // Store original implementations
    if (typeof fetch !== 'undefined') {
      this.originalFetch = fetch.bind(window);
      this.patchFetch();
    }
    
    if (typeof XMLHttpRequest !== 'undefined') {
      this.originalXMLHttpRequest = XMLHttpRequest;
      this.patchXMLHttpRequest();
    }
    
    // Monitor performance timing APIs
    if (this.config.enableResourceTimingProtection) {
      this.monitorResourceTiming();
    }
    
    // Block dangerous CSP bypasses
    this.blockCSPBypass();
    
    // Monitor postMessage for cross-origin attacks
    this.monitorPostMessage();
    
    console.log('CrossOriginProtection initialized with config:', this.config);
  }
  
  /**
   * CROSS-ORIGIN RESOURCE TIMING ATTACK BUG FIX: Patch fetch API
   */
  private patchFetch(): void {
    (window as any).fetch = async (input: RequestInfo | URL, init?: RequestInit): Promise<Response> => {
      const url = typeof input === 'string' ? input : input instanceof URL ? input.href : input.url;
      const origin = this.extractOrigin(url);
      
      // Validate cross-origin request
      if (!this.validateCrossOriginRequest(origin, 'fetch')) {
        const threat: CrossOriginThreat = {
          type: 'blocked_fetch_request',
          severity: 'high',
          description: `Blocked cross-origin fetch request to: ${origin}`,
          origin,
          timestamp: Date.now(),
          blocked: true
        };
        
        this.recordThreat(threat);
        throw new Error(`Cross-origin request blocked: ${origin}`);
      }
      
      // Add timing jitter
      if (this.config.enableTimingJitter) {
        await this.addNetworkTimingJitter();
      }
      
      // Execute request with resource timing protection
      const startTime = performance.now();
      
      try {
        // Add secure headers
        const secureInit = this.addSecureHeaders(init, origin);
        
        const response = await this.originalFetch(input, secureInit);
        
        // Record and obfuscate timing
        const duration = performance.now() - startTime;
        this.recordResourceTiming(url, startTime, duration, response.headers.get('content-length'), origin);
        
        // Validate response
        this.validateResponse(response, origin);
        
        return response;
      } catch (error) {
        // Record failed request
        const duration = performance.now() - startTime;
        this.recordResourceTiming(url, startTime, duration, 0, origin, true);
        throw error;
      }
    };
  }
  
  /**
   * CROSS-ORIGIN RESOURCE TIMING ATTACK BUG FIX: Patch XMLHttpRequest
   */
  private patchXMLHttpRequest(): void {
    const CrossOriginProtectionInstance = this;
    
    (window as any).XMLHttpRequest = class extends this.originalXMLHttpRequest {
      private _url: string = '';
      private _origin: string = '';
      private _startTime: number = 0;
      
      constructor() {
        super();
        
        // Override addEventListener to monitor events
        const originalAddEventListener = this.addEventListener.bind(this);
        this.addEventListener = function(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions) {
          // Wrap listener to add timing protection
          const wrappedListener = CrossOriginProtectionInstance.wrapXHREventListener(type, listener, this._origin);
          return originalAddEventListener(type, wrappedListener, options);
        };
      }
      
      open(method: string, url: string, async?: boolean, user?: string | null, password?: string | null): void {
        this._url = url;
        this._origin = CrossOriginProtectionInstance.extractOrigin(url);
        
        // Validate cross-origin request
        if (!CrossOriginProtectionInstance.validateCrossOriginRequest(this._origin, 'XMLHttpRequest')) {
          const threat: CrossOriginThreat = {
            type: 'blocked_xhr_request',
            severity: 'high',
            description: `Blocked cross-origin XHR request to: ${this._origin}`,
            origin: this._origin,
            timestamp: Date.now(),
            blocked: true
          };
          
          CrossOriginProtectionInstance.recordThreat(threat);
          throw new Error(`Cross-origin XHR request blocked: ${this._origin}`);
        }
        
        return super.open(method, url, async, user, password);
      }
      
      send(body?: Document | XMLHttpRequestBodyInit | null): void {
        this._startTime = performance.now();
        
        // Add timing jitter before send
        if (CrossOriginProtectionInstance.config.enableTimingJitter) {
          setTimeout(() => {
            super.send(body);
          }, CrossOriginProtectionInstance.getTimingJitter());
        } else {
          super.send(body);
        }
      }
      
      setRequestHeader(name: string, value: string): void {
        // Validate headers for security
        if (CrossOriginProtectionInstance.isSecureHeader(name, value, this._origin)) {
          super.setRequestHeader(name, value);
        } else {
          console.warn(`Insecure header blocked: ${name}`);
        }
      }
    };
  }\n  \n  /**\n   * CROSS-ORIGIN RESOURCE TIMING ATTACK BUG FIX: Wrap XHR event listeners\n   */\n  private wrapXHREventListener(type: string, listener: EventListenerOrEventListenerObject, origin: string): EventListenerOrEventListenerObject {\n    const protection = this;\n    \n    return function(this: XMLHttpRequest, event: Event) {\n      // Record timing for monitoring\n      if (type === 'loadend' || type === 'load') {\n        const duration = performance.now() - (this as any)._startTime;\n        const contentLength = this.getResponseHeader('content-length');\n        const size = contentLength ? parseInt(contentLength, 10) : 0;\n        \n        protection.recordResourceTiming(\n          (this as any)._url,\n          (this as any)._startTime,\n          duration,\n          size,\n          origin\n        );\n      }\n      \n      // Add timing jitter before calling original listener\n      if (protection.config.enableTimingJitter) {\n        setTimeout(() => {\n          if (typeof listener === 'function') {\n            listener.call(this, event);\n          } else {\n            listener.handleEvent.call(listener, event);\n          }\n        }, protection.getTimingJitter());\n      } else {\n        if (typeof listener === 'function') {\n          listener.call(this, event);\n        } else {\n          listener.handleEvent.call(listener, event);\n        }\n      }\n    };\n  }\n  \n  /**\n   * CROSS-ORIGIN RESOURCE TIMING ATTACK BUG FIX: Monitor resource timing API\n   */\n  private monitorResourceTiming(): void {\n    if (typeof PerformanceObserver !== 'undefined') {\n      try {\n        const observer = new PerformanceObserver((list) => {\n          const entries = list.getEntries();\n          \n          for (const entry of entries) {\n            if (entry.entryType === 'resource') {\n              const resourceEntry = entry as PerformanceResourceTiming;\n              const origin = this.extractOrigin(resourceEntry.name);\n              \n              // Check for suspicious timing patterns\n              const isSuspicious = this.detectSuspiciousResourceTiming(resourceEntry);\n              \n              if (isSuspicious) {\n                this.recordThreat({\n                  type: 'suspicious_resource_timing',\n                  severity: 'medium',\n                  description: `Suspicious resource timing pattern detected: ${resourceEntry.name}`,\n                  origin,\n                  timestamp: Date.now(),\n                  blocked: false\n                });\n              }\n              \n              // Obfuscate timing information\n              this.obfuscateResourceTiming(resourceEntry);\n            }\n          }\n        });\n        \n        observer.observe({ entryTypes: ['resource'] });\n      } catch (error) {\n        console.warn('PerformanceObserver not supported or failed to initialize');\n      }\n    }\n    \n    // Also patch performance.getEntriesByType\n    if (typeof performance !== 'undefined' && performance.getEntriesByType) {\n      const originalGetEntriesByType = performance.getEntriesByType.bind(performance);\n      \n      performance.getEntriesByType = (type: string): PerformanceEntry[] => {\n        const entries = originalGetEntriesByType(type);\n        \n        if (type === 'resource') {\n          // Return obfuscated timing data\n          return entries.map(entry => this.createObfuscatedResourceEntry(entry as PerformanceResourceTiming));\n        }\n        \n        return entries;\n      };\n    }\n  }\n  \n  /**\n   * CROSS-ORIGIN RESOURCE TIMING ATTACK BUG FIX: Block CSP bypass attempts\n   */\n  private blockCSPBypass(): void {\n    // Monitor dynamic script creation\n    if (typeof document !== 'undefined') {\n      const originalCreateElement = document.createElement.bind(document);\n      \n      document.createElement = function<K extends keyof HTMLElementTagNameMap>(tagName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K] {\n        const element = originalCreateElement(tagName, options);\n        \n        if (tagName.toLowerCase() === 'script') {\n          const scriptElement = element as unknown as HTMLScriptElement;\n          \n          // Monitor src attribute changes\n          const originalSetAttribute = scriptElement.setAttribute.bind(scriptElement);\n          scriptElement.setAttribute = function(name: string, value: string) {\n            if (name.toLowerCase() === 'src') {\n              const origin = CrossOriginProtection.getInstance().extractOrigin(value);\n              \n              if (!CrossOriginProtection.getInstance().validateCrossOriginRequest(origin, 'script')) {\n                CrossOriginProtection.getInstance().recordThreat({\n                  type: 'blocked_script_injection',\n                  severity: 'critical',\n                  description: `Blocked cross-origin script injection: ${value}`,\n                  origin,\n                  timestamp: Date.now(),\n                  blocked: true\n                });\n                \n                throw new Error(`Cross-origin script blocked: ${origin}`);\n              }\n            }\n            \n            return originalSetAttribute(name, value);\n          };\n        }\n        \n        return element;\n      };\n    }\n  }\n  \n  /**\n   * CROSS-ORIGIN RESOURCE TIMING ATTACK BUG FIX: Monitor postMessage\n   */\n  private monitorPostMessage(): void {\n    if (typeof window !== 'undefined') {\n      // Monitor outgoing postMessage\n      const originalPostMessage = window.postMessage.bind(window);\n      \n      window.postMessage = (message: any, targetOrigin: string, transfer?: Transferable[]) => {\n        // Validate target origin\n        if (targetOrigin !== '*' && !this.validateOrigin(targetOrigin)) {\n          this.recordThreat({\n            type: 'blocked_postmessage',\n            severity: 'medium',\n            description: `Blocked postMessage to unauthorized origin: ${targetOrigin}`,\n            origin: targetOrigin,\n            timestamp: Date.now(),\n            blocked: true\n          });\n          \n          throw new Error(`postMessage blocked to unauthorized origin: ${targetOrigin}`);\n        }\n        \n        // Sanitize message data\n        const sanitizedMessage = this.sanitizePostMessageData(message);\n        \n        return originalPostMessage(sanitizedMessage, targetOrigin, transfer);\n      };\n      \n      // Monitor incoming postMessage\n      window.addEventListener('message', (event: MessageEvent) => {\n        if (!this.validateOrigin(event.origin)) {\n          this.recordThreat({\n            type: 'untrusted_postmessage_received',\n            severity: 'high',\n            description: `Received postMessage from untrusted origin: ${event.origin}`,\n            origin: event.origin,\n            timestamp: Date.now(),\n            blocked: false\n          });\n          \n          // Don't process the message\n          event.stopImmediatePropagation();\n          return;\n        }\n        \n        // Validate message data\n        if (!this.validatePostMessageData(event.data)) {\n          this.recordThreat({\n            type: 'malicious_postmessage_data',\n            severity: 'high',\n            description: `Malicious postMessage data from: ${event.origin}`,\n            origin: event.origin,\n            timestamp: Date.now(),\n            blocked: false\n          });\n        }\n      }, true); // Use capture phase\n    }\n  }\n  \n  /**\n   * CROSS-ORIGIN RESOURCE TIMING ATTACK BUG FIX: Validate cross-origin requests\n   */\n  private validateCrossOriginRequest(origin: string, requestType: string): boolean {\n    // Check cache first\n    const cacheKey = `${origin}_${requestType}`;\n    const cached = this.originValidationCache.get(cacheKey);\n    \n    if (cached && Date.now() - cached.timestamp < 300000) { // 5 minute cache\n      return cached.valid;\n    }\n    \n    // Same-origin is always allowed\n    if (this.isSameOrigin(origin)) {\n      this.originValidationCache.set(cacheKey, { valid: true, timestamp: Date.now() });\n      return true;\n    }\n    \n    // Check against allowed origins\n    const isValid = this.config.allowedOrigins.some(allowedOrigin => {\n      if (allowedOrigin === '*') return true;\n      if (allowedOrigin === origin) return true;\n      \n      // Support wildcard subdomains\n      if (allowedOrigin.startsWith('*.')) {\n        const domain = allowedOrigin.substring(2);\n        return origin.endsWith('.' + domain) || origin === domain;\n      }\n      \n      return false;\n    });\n    \n    // Cache result\n    this.originValidationCache.set(cacheKey, { valid: isValid, timestamp: Date.now() });\n    \n    return isValid;\n  }\n  \n  /**\n   * CROSS-ORIGIN RESOURCE TIMING ATTACK BUG FIX: Extract origin from URL\n   */\n  private extractOrigin(url: string): string {\n    try {\n      const urlObj = new URL(url, window.location.href);\n      return `${urlObj.protocol}//${urlObj.host}`;\n    } catch (error) {\n      // If URL parsing fails, treat as same-origin\n      return window.location.origin;\n    }\n  }\n  \n  /**\n   * CROSS-ORIGIN RESOURCE TIMING ATTACK BUG FIX: Check if origin is same-origin\n   */\n  private isSameOrigin(origin: string): boolean {\n    return origin === window.location.origin;\n  }\n  \n  /**\n   * CROSS-ORIGIN RESOURCE TIMING ATTACK BUG FIX: Validate origin\n   */\n  private validateOrigin(origin: string): boolean {\n    // Null origin check\n    if (!origin || origin === 'null') {\n      return false;\n    }\n    \n    return this.validateCrossOriginRequest(origin, 'general');\n  }\n  \n  /**\n   * CROSS-ORIGIN RESOURCE TIMING ATTACK BUG FIX: Add secure headers\n   */\n  private addSecureHeaders(init?: RequestInit, origin?: string): RequestInit {\n    const secureInit: RequestInit = { ...init };\n    \n    if (!secureInit.headers) {\n      secureInit.headers = {};\n    }\n    \n    const headers = secureInit.headers as Record<string, string>;\n    \n    // Add CORS headers if cross-origin\n    if (origin && !this.isSameOrigin(origin)) {\n      headers['X-Requested-With'] = 'XMLHttpRequest';\n      \n      if (this.config.credentials) {\n        secureInit.credentials = 'include';\n      }\n    }\n    \n    // Add security headers\n    headers['X-Content-Type-Options'] = 'nosniff';\n    headers['X-Frame-Options'] = 'DENY';\n    headers['X-XSS-Protection'] = '1; mode=block';\n    \n    return secureInit;\n  }\n  \n  /**\n   * CROSS-ORIGIN RESOURCE TIMING ATTACK BUG FIX: Validate response\n   */\n  private validateResponse(response: Response, origin: string): void {\n    // Check for suspicious response patterns\n    const contentType = response.headers.get('content-type');\n    \n    if (contentType && contentType.includes('text/html') && !this.isSameOrigin(origin)) {\n      this.recordThreat({\n        type: 'suspicious_html_response',\n        severity: 'medium',\n        description: `Cross-origin HTML response from: ${origin}`,\n        origin,\n        timestamp: Date.now(),\n        blocked: false\n      });\n    }\n    \n    // Check for missing CORS headers\n    if (!this.isSameOrigin(origin)) {\n      const corsOrigin = response.headers.get('access-control-allow-origin');\n      if (!corsOrigin) {\n        this.recordThreat({\n          type: 'missing_cors_headers',\n          severity: 'low',\n          description: `Missing CORS headers from: ${origin}`,\n          origin,\n          timestamp: Date.now(),\n          blocked: false\n        });\n      }\n    }\n  }\n  \n  /**\n   * CROSS-ORIGIN RESOURCE TIMING ATTACK BUG FIX: Check if header is secure\n   */\n  private isSecureHeader(name: string, value: string, origin: string): boolean {\n    const lowerName = name.toLowerCase();\n    \n    // Block dangerous headers\n    const dangerousHeaders = [\n      'cookie',\n      'set-cookie',\n      'x-forwarded-for',\n      'x-real-ip',\n      'host'\n    ];\n    \n    if (dangerousHeaders.includes(lowerName)) {\n      return false;\n    }\n    \n    // Validate CORS headers\n    if (!this.isSameOrigin(origin)) {\n      const allowedCorsHeaders = this.config.allowedHeaders.map(h => h.toLowerCase());\n      if (!allowedCorsHeaders.includes(lowerName) && !lowerName.startsWith('x-')) {\n        return false;\n      }\n    }\n    \n    return true;\n  }\n  \n  /**\n   * CROSS-ORIGIN RESOURCE TIMING ATTACK BUG FIX: Add network timing jitter\n   */\n  private async addNetworkTimingJitter(): Promise<void> {\n    const jitter = this.getTimingJitter();\n    \n    if (jitter > 0) {\n      await new Promise(resolve => setTimeout(resolve, jitter));\n    }\n  }\n  \n  /**\n   * CROSS-ORIGIN RESOURCE TIMING ATTACK BUG FIX: Get timing jitter\n   */\n  private getTimingJitter(): number {\n    if (!this.config.enableTimingJitter) return 0;\n    \n    // Generate cryptographically secure jitter between 0-50ms\n    if (typeof crypto !== 'undefined' && crypto.getRandomValues) {\n      const array = new Uint32Array(1);\n      crypto.getRandomValues(array);\n      return (array[0] / 0xFFFFFFFF) * 50;\n    } else {\n      return Math.random() * 50;\n    }\n  }\n  \n  /**\n   * CROSS-ORIGIN RESOURCE TIMING ATTACK BUG FIX: Record resource timing\n   */\n  private recordResourceTiming(name: string, startTime: number, duration: number, transferSize: number | string | null, origin: string, failed: boolean = false): void {\n    const size = typeof transferSize === 'string' ? parseInt(transferSize, 10) : (transferSize || 0);\n    \n    const entry: ResourceTimingEntry = {\n      name,\n      startTime: this.obfuscateTimingValue(startTime),\n      duration: this.obfuscateTimingValue(duration),\n      transferSize: size,\n      origin,\n      suspicious: failed || this.detectSuspiciousNetworkPattern(name, duration, size)\n    };\n    \n    this.resourceTimings.push(entry);\n    \n    // Keep only recent entries\n    if (this.resourceTimings.length > 1000) {\n      this.resourceTimings = this.resourceTimings.slice(-1000);\n    }\n  }\n  \n  /**\n   * CROSS-ORIGIN RESOURCE TIMING ATTACK BUG FIX: Detect suspicious resource timing\n   */\n  private detectSuspiciousResourceTiming(entry: PerformanceResourceTiming): boolean {\n    // Check for unusually precise timing\n    const precision = this.getTimingPrecision(entry.responseEnd - entry.responseStart);\n    if (precision > 0.1) { // More than 0.1ms precision is suspicious\n      return true;\n    }\n    \n    // Check for timing patterns that might indicate probing\n    const duration = entry.responseEnd - entry.requestStart;\n    if (duration < 1 || duration > 30000) { // Less than 1ms or more than 30s\n      return true;\n    }\n    \n    // Check for suspicious size patterns\n    if (entry.transferSize === 0 && entry.responseEnd > entry.responseStart) {\n      return true; // Response took time but no data transferred\n    }\n    \n    return false;\n  }\n  \n  /**\n   * CROSS-ORIGIN RESOURCE TIMING ATTACK BUG FIX: Detect suspicious network patterns\n   */\n  private detectSuspiciousNetworkPattern(name: string, duration: number, size: number): boolean {\n    // Check for timing attack patterns\n    if (duration < 0.5 && size === 0) {\n      return true; // Extremely fast request with no data\n    }\n    \n    // Check for probe-like requests\n    const url = new URL(name, window.location.href);\n    const suspiciousPatterns = [\n      /\\.(git|svn|env|backup|config)$/i,\n      /admin|test|debug|internal/i,\n      /\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}/, // IP addresses\n    ];\n    \n    return suspiciousPatterns.some(pattern => pattern.test(url.pathname));\n  }\n  \n  /**\n   * CROSS-ORIGIN RESOURCE TIMING ATTACK BUG FIX: Get timing precision\n   */\n  private getTimingPrecision(value: number): number {\n    const str = value.toString();\n    const decimalIndex = str.indexOf('.');\n    \n    if (decimalIndex === -1) return 0;\n    \n    return str.length - decimalIndex - 1;\n  }\n  \n  /**\n   * CROSS-ORIGIN RESOURCE TIMING ATTACK BUG FIX: Obfuscate timing values\n   */\n  private obfuscateTimingValue(value: number): number {\n    const key = value.toFixed(2);\n    \n    if (!this.timingObfuscationMap.has(key)) {\n      // Add random jitter Â±2ms\n      const jitter = (Math.random() - 0.5) * 4;\n      const obfuscated = Math.max(0, value + jitter);\n      \n      // Round to reduce precision\n      const rounded = Math.round(obfuscated * 10) / 10; // 0.1ms precision\n      \n      this.timingObfuscationMap.set(key, rounded);\n    }\n    \n    return this.timingObfuscationMap.get(key)!;\n  }\n  \n  /**\n   * CROSS-ORIGIN RESOURCE TIMING ATTACK BUG FIX: Create obfuscated resource entry\n   */\n  private createObfuscatedResourceEntry(original: PerformanceResourceTiming): PerformanceResourceTiming {\n    // Create a proxy object that obfuscates timing values\n    return new Proxy(original, {\n      get: (target, prop) => {\n        const timingProps = [\n          'connectEnd', 'connectStart', 'domainLookupEnd', 'domainLookupStart',\n          'fetchStart', 'redirectEnd', 'redirectStart', 'requestStart',\n          'responseEnd', 'responseStart', 'secureConnectionStart', 'startTime',\n          'duration'\n        ];\n        \n        if (timingProps.includes(prop as string)) {\n          const value = target[prop as keyof PerformanceResourceTiming] as number;\n          return this.obfuscateTimingValue(value);\n        }\n        \n        return target[prop as keyof PerformanceResourceTiming];\n      }\n    });\n  }\n  \n  /**\n   * CROSS-ORIGIN RESOURCE TIMING ATTACK BUG FIX: Sanitize postMessage data\n   */\n  private sanitizePostMessageData(data: any): any {\n    if (typeof data === 'string') {\n      // Remove dangerous patterns\n      return data\n        .replace(/<script[^>]*>.*?<\\/script>/gi, '')\n        .replace(/javascript:/gi, '')\n        .replace(/data:text\\/html/gi, '')\n        .replace(/vbscript:/gi, '');\n    }\n    \n    if (data && typeof data === 'object') {\n      // Remove dangerous properties\n      const sanitized = { ...data };\n      const dangerousProps = ['__proto__', 'constructor', 'prototype'];\n      \n      dangerousProps.forEach(prop => {\n        delete sanitized[prop];\n      });\n      \n      return sanitized;\n    }\n    \n    return data;\n  }\n  \n  /**\n   * CROSS-ORIGIN RESOURCE TIMING ATTACK BUG FIX: Validate postMessage data\n   */\n  private validatePostMessageData(data: any): boolean {\n    if (typeof data === 'string') {\n      // Check for dangerous patterns\n      const dangerousPatterns = [\n        /<script[^>]*>/i,\n        /javascript:/i,\n        /data:text\\/html/i,\n        /vbscript:/i,\n        /on[a-z]+\\s*=/i\n      ];\n      \n      return !dangerousPatterns.some(pattern => pattern.test(data));\n    }\n    \n    if (data && typeof data === 'object') {\n      // Check for prototype pollution\n      const dangerousProps = ['__proto__', 'constructor', 'prototype'];\n      return !dangerousProps.some(prop => prop in data);\n    }\n    \n    return true;\n  }\n  \n  /**\n   * CROSS-ORIGIN RESOURCE TIMING ATTACK BUG FIX: Record security threat\n   */\n  private recordThreat(threat: CrossOriginThreat): void {\n    this.threats.push(threat);\n    \n    // Keep only recent threats (last 1000)\n    if (this.threats.length > 1000) {\n      this.threats = this.threats.slice(-1000);\n    }\n    \n    console.warn('Cross-origin security threat recorded:', threat);\n  }\n  \n  /**\n   * Get security statistics\n   */\n  getSecurityStats(): {\n    totalThreats: number;\n    blockedRequests: number;\n    suspiciousTimings: number;\n    config: CORSConfiguration;\n    recentThreats: CrossOriginThreat[];\n  } {\n    const blockedRequests = this.threats.filter(t => t.blocked).length;\n    const suspiciousTimings = this.resourceTimings.filter(r => r.suspicious).length;\n    \n    return {\n      totalThreats: this.threats.length,\n      blockedRequests,\n      suspiciousTimings,\n      config: this.config,\n      recentThreats: this.threats.slice(-50)\n    };\n  }\n  \n  /**\n   * Update configuration\n   */\n  updateConfig(newConfig: Partial<CORSConfiguration>): void {\n    this.config = { ...this.config, ...newConfig };\n    \n    // Clear cache when config changes\n    this.originValidationCache.clear();\n    \n    console.log('CrossOriginProtection configuration updated:', this.config);\n  }\n  \n  /**\n   * Cleanup and restore original implementations\n   */\n  cleanup(): void {\n    if (this.originalFetch && typeof window !== 'undefined') {\n      (window as any).fetch = this.originalFetch;\n    }\n    \n    if (this.originalXMLHttpRequest && typeof window !== 'undefined') {\n      (window as any).XMLHttpRequest = this.originalXMLHttpRequest;\n    }\n    \n    this.threats = [];\n    this.resourceTimings = [];\n    this.timingObfuscationMap.clear();\n    this.originValidationCache.clear();\n    \n    console.log('CrossOriginProtection cleanup complete');\n  }\n}\n\n// Auto-initialize protection with default settings\nlet autoProtection: CrossOriginProtection | null = null;\n\nif (typeof window !== 'undefined') {\n  // Initialize protection on page load\n  if (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', () => {\n      autoProtection = CrossOriginProtection.getInstance();\n    });\n  } else {\n    autoProtection = CrossOriginProtection.getInstance();\n  }\n  \n  // Cleanup on page unload\n  window.addEventListener('beforeunload', () => {\n    if (autoProtection) {\n      autoProtection.cleanup();\n    }\n  });\n}\n\nexport default CrossOriginProtection;