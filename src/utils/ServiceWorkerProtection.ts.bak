/**
 * SERVICE WORKER PERSISTENCE BUG FIX: Comprehensive Service Worker and Background Exploitation Protection
 * 
 * This module provides protection against Service Worker persistence attacks,
 * background exploitation, and related web worker vulnerabilities.
 */

export interface ServiceWorkerThreat {
  type: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  mitigated: boolean;
  timestamp: number;
}

export interface ServiceWorkerSecurityConfig {
  maxWorkerLifetime: number;
  maxConcurrentWorkers: number;
  maxMemoryUsage: number;
  allowServiceWorkers: boolean;
  allowBackgroundSync: boolean;
  allowPersistentNotifications: boolean;
  blockSuspiciousOrigins: boolean;
}

/**
 * SERVICE WORKER PERSISTENCE BUG FIX: Main protection class
 */
export class ServiceWorkerProtection {
  private static instance: ServiceWorkerProtection;
  private config: ServiceWorkerSecurityConfig;
  private activeWorkers: Map<string, { worker: Worker; startTime: number; operations: number }> = new Map();
  private threats: ServiceWorkerThreat[] = [];
  private monitorInterval: NodeJS.Timeout | null = null;
  
  private readonly DEFAULT_CONFIG: ServiceWorkerSecurityConfig = {
    maxWorkerLifetime: 10 * 60 * 1000, // 10 minutes
    maxConcurrentWorkers: 5,
    maxMemoryUsage: 200 * 1024 * 1024, // 200MB
    allowServiceWorkers: false, // Disabled by default for security
    allowBackgroundSync: false,
    allowPersistentNotifications: false,
    blockSuspiciousOrigins: true
  };
  
  static getInstance(config?: Partial<ServiceWorkerSecurityConfig>): ServiceWorkerProtection {
    if (!this.instance) {
      this.instance = new ServiceWorkerProtection(config);
    }
    return this.instance;
  }
  
  private constructor(config?: Partial<ServiceWorkerSecurityConfig>) {
    this.config = { ...this.DEFAULT_CONFIG, ...config };
    this.initializeProtection();
  }
  
  /**
   * SERVICE WORKER PERSISTENCE BUG FIX: Initialize comprehensive protection
   */
  private initializeProtection(): void {
    // Block Service Worker registration if disabled
    if (!this.config.allowServiceWorkers && typeof navigator !== 'undefined') {
      this.blockServiceWorkerRegistration();
    }
    
    // Monitor existing workers
    this.startWorkerMonitoring();
    
    // Block dangerous APIs
    this.blockDangerousAPIs();
    
    // Monitor storage persistence
    this.monitorStoragePersistence();
    
    console.log('ServiceWorkerProtection initialized with config:', this.config);
  }
  
  /**
   * SERVICE WORKER PERSISTENCE BUG FIX: Block Service Worker registration
   */
  private blockServiceWorkerRegistration(): void {
    if (typeof navigator !== 'undefined' && navigator.serviceWorker) {
      // Override service worker registration
      const originalRegister = navigator.serviceWorker.register.bind(navigator.serviceWorker);
      
      navigator.serviceWorker.register = async (scriptURL: string | URL, options?: RegistrationOptions) => {
        const threat: ServiceWorkerThreat = {
          type: 'service_worker_registration_blocked',
          severity: 'high',
          description: `Service Worker registration blocked: ${scriptURL}`,
          mitigated: true,
          timestamp: Date.now()
        };
        
        this.threats.push(threat);
        console.warn('Service Worker registration blocked for security:', scriptURL);
        
        // Return rejected promise
        throw new Error('Service Worker registration blocked by security policy');
      };
      
      // Block getRegistration and getRegistrations
      const originalGetRegistration = navigator.serviceWorker.getRegistration.bind(navigator.serviceWorker);
      navigator.serviceWorker.getRegistration = async (scope?: string) => {
        console.warn('Service Worker getRegistration blocked');
        return undefined;
      };
      
      const originalGetRegistrations = navigator.serviceWorker.getRegistrations.bind(navigator.serviceWorker);
      navigator.serviceWorker.getRegistrations = async () => {
        console.warn('Service Worker getRegistrations blocked');
        return [];
      };
    }
  }
  
  /**
   * SERVICE WORKER PERSISTENCE BUG FIX: Monitor worker activity
   */
  private startWorkerMonitoring(): void {
    this.monitorInterval = setInterval(() => {
      this.checkWorkerLimits();
      this.cleanupExpiredWorkers();
      this.monitorMemoryUsage();
    }, 30000); // Every 30 seconds
  }
  
  /**
   * SERVICE WORKER PERSISTENCE BUG FIX: Check worker limits
   */
  private checkWorkerLimits(): void {
    const currentTime = Date.now();
    
    for (const [id, workerInfo] of this.activeWorkers) {
      const lifetime = currentTime - workerInfo.startTime;
      
      // Check lifetime limit
      if (lifetime > this.config.maxWorkerLifetime) {
        this.terminateWorker(id, 'Lifetime limit exceeded');
      }
      
      // Check operation count (suspicious if too many)
      if (workerInfo.operations > 1000) {
        this.recordThreat({
          type: 'excessive_worker_operations',
          severity: 'medium',
          description: `Worker ${id} has performed ${workerInfo.operations} operations`,
          mitigated: false,
          timestamp: currentTime
        });
      }
    }
  }
  
  /**
   * SERVICE WORKER PERSISTENCE BUG FIX: Memory usage monitoring
   */
  private monitorMemoryUsage(): void {
    if (typeof performance !== 'undefined' && performance.memory) {
      const memoryUsage = performance.memory.usedJSHeapSize;
      
      if (memoryUsage > this.config.maxMemoryUsage) {
        this.recordThreat({
          type: 'excessive_memory_usage',
          severity: 'high',
          description: `Memory usage exceeded limit: ${(memoryUsage / 1024 / 1024).toFixed(2)}MB`,
          mitigated: false,
          timestamp: Date.now()
        });
        
        // Terminate workers to free memory
        this.emergencyWorkerCleanup();
      }
    }
  }
  
  /**
   * SERVICE WORKER PERSISTENCE BUG FIX: Block dangerous APIs
   */
  private blockDangerousAPIs(): void {
    // Block SharedArrayBuffer if available (Spectre mitigation)
    if (typeof SharedArrayBuffer !== 'undefined') {
      (window as any).SharedArrayBuffer = undefined;
      console.log('SharedArrayBuffer blocked for Spectre protection');
    }\n    \n    // Monitor and limit Web Workers\n    if (typeof Worker !== 'undefined') {\n      const OriginalWorker = Worker;\n      \n      (window as any).Worker = class extends OriginalWorker {\n        constructor(scriptURL: string | URL, options?: WorkerOptions) {\n          // Check concurrent worker limit\n          if (ServiceWorkerProtection.getInstance().activeWorkers.size >= ServiceWorkerProtection.getInstance().config.maxConcurrentWorkers) {\n            throw new Error('Maximum concurrent workers exceeded');\n          }\n          \n          super(scriptURL, options);\n          \n          // Register worker\n          const workerId = `worker_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n          ServiceWorkerProtection.getInstance().registerWorker(workerId, this);\n          \n          // Monitor worker messages\n          this.addEventListener('message', (event) => {\n            ServiceWorkerProtection.getInstance().monitorWorkerMessage(workerId, event);\n          });\n          \n          // Handle worker termination\n          this.addEventListener('error', () => {\n            ServiceWorkerProtection.getInstance().unregisterWorker(workerId);\n          });\n        }\n      };\n    }\n    \n    // Block dangerous storage APIs\n    this.blockPersistentStorage();\n  }\n  \n  /**\n   * SERVICE WORKER PERSISTENCE BUG FIX: Block persistent storage\n   */\n  private blockPersistentStorage(): void {\n    // Block persistent storage requests\n    if (typeof navigator !== 'undefined' && navigator.storage && navigator.storage.persist) {\n      const originalPersist = navigator.storage.persist.bind(navigator.storage);\n      \n      navigator.storage.persist = async () => {\n        this.recordThreat({\n          type: 'persistent_storage_blocked',\n          severity: 'medium',\n          description: 'Persistent storage request blocked',\n          mitigated: true,\n          timestamp: Date.now()\n        });\n        \n        console.warn('Persistent storage request blocked');\n        return false;\n      };\n    }\n    \n    // Monitor localStorage and sessionStorage for suspicious patterns\n    this.monitorStorageAPIs();\n  }\n  \n  /**\n   * SERVICE WORKER PERSISTENCE BUG FIX: Monitor storage APIs\n   */\n  private monitorStorageAPIs(): void {\n    if (typeof Storage !== 'undefined') {\n      // Monitor localStorage\n      const originalSetItem = Storage.prototype.setItem;\n      Storage.prototype.setItem = function(key: string, value: string) {\n        if (ServiceWorkerProtection.getInstance().isSuspiciousStorageKey(key, value)) {\n          console.warn('Suspicious storage operation blocked:', key);\n          return;\n        }\n        \n        return originalSetItem.call(this, key, value);\n      };\n    }\n  }\n  \n  /**\n   * SERVICE WORKER PERSISTENCE BUG FIX: Check for suspicious storage patterns\n   */\n  private isSuspiciousStorageKey(key: string, value: string): boolean {\n    const suspiciousPatterns = [\n      /service.*worker/i,\n      /background.*sync/i,\n      /persistent.*data/i,\n      /cross.*session/i,\n      /exploit/i,\n      /payload/i,\n      /backdoor/i,\n      /__proto__/i,\n      /constructor/i,\n      /eval/i,\n      /function.*\\(/i,\n      /<script/i\n    ];\n    \n    const combinedData = key + value;\n    \n    return suspiciousPatterns.some(pattern => pattern.test(combinedData));\n  }\n  \n  /**\n   * SERVICE WORKER PERSISTENCE BUG FIX: Monitor storage persistence\n   */\n  private monitorStoragePersistence(): void {\n    if (typeof navigator !== 'undefined' && navigator.storage) {\n      // Check storage estimate periodically\n      setInterval(async () => {\n        try {\n          if (navigator.storage.estimate) {\n            const estimate = await navigator.storage.estimate();\n            const usagePercent = estimate.usage && estimate.quota ? \n              (estimate.usage / estimate.quota) * 100 : 0;\n            \n            if (usagePercent > 90) {\n              this.recordThreat({\n                type: 'excessive_storage_usage',\n                severity: 'medium',\n                description: `Storage usage at ${usagePercent.toFixed(2)}%`,\n                mitigated: false,\n                timestamp: Date.now()\n              });\n            }\n          }\n        } catch (error) {\n          // Storage API not available or blocked\n        }\n      }, 60000); // Every minute\n    }\n  }\n  \n  /**\n   * SERVICE WORKER PERSISTENCE BUG FIX: Register worker\n   */\n  registerWorker(id: string, worker: Worker): void {\n    this.activeWorkers.set(id, {\n      worker,\n      startTime: Date.now(),\n      operations: 0\n    });\n    \n    console.log(`Worker registered: ${id}`);\n  }\n  \n  /**\n   * SERVICE WORKER PERSISTENCE BUG FIX: Unregister worker\n   */\n  unregisterWorker(id: string): void {\n    this.activeWorkers.delete(id);\n    console.log(`Worker unregistered: ${id}`);\n  }\n  \n  /**\n   * SERVICE WORKER PERSISTENCE BUG FIX: Monitor worker messages\n   */\n  private monitorWorkerMessage(workerId: string, event: MessageEvent): void {\n    const workerInfo = this.activeWorkers.get(workerId);\n    if (workerInfo) {\n      workerInfo.operations++;\n      \n      // Check message size\n      try {\n        const messageSize = JSON.stringify(event.data).length;\n        if (messageSize > 10 * 1024 * 1024) { // 10MB\n          this.recordThreat({\n            type: 'large_worker_message',\n            severity: 'high',\n            description: `Large message from worker ${workerId}: ${messageSize} bytes`,\n            mitigated: false,\n            timestamp: Date.now()\n          });\n        }\n      } catch (error) {\n        // Message not serializable\n      }\n    }\n  }\n  \n  /**\n   * SERVICE WORKER PERSISTENCE BUG FIX: Terminate worker\n   */\n  private terminateWorker(workerId: string, reason: string): void {\n    const workerInfo = this.activeWorkers.get(workerId);\n    if (workerInfo) {\n      try {\n        workerInfo.worker.terminate();\n        this.activeWorkers.delete(workerId);\n        \n        this.recordThreat({\n          type: 'worker_terminated',\n          severity: 'medium',\n          description: `Worker ${workerId} terminated: ${reason}`,\n          mitigated: true,\n          timestamp: Date.now()\n        });\n        \n        console.log(`Worker ${workerId} terminated: ${reason}`);\n      } catch (error) {\n        console.error(`Error terminating worker ${workerId}:`, error);\n      }\n    }\n  }\n  \n  /**\n   * SERVICE WORKER PERSISTENCE BUG FIX: Emergency worker cleanup\n   */\n  private emergencyWorkerCleanup(): void {\n    console.warn('Emergency worker cleanup initiated due to memory pressure');\n    \n    for (const [id, workerInfo] of this.activeWorkers) {\n      this.terminateWorker(id, 'Emergency cleanup');\n    }\n  }\n  \n  /**\n   * SERVICE WORKER PERSISTENCE BUG FIX: Clean up expired workers\n   */\n  private cleanupExpiredWorkers(): void {\n    const currentTime = Date.now();\n    const expiredWorkers: string[] = [];\n    \n    for (const [id, workerInfo] of this.activeWorkers) {\n      const lifetime = currentTime - workerInfo.startTime;\n      if (lifetime > this.config.maxWorkerLifetime) {\n        expiredWorkers.push(id);\n      }\n    }\n    \n    expiredWorkers.forEach(id => this.terminateWorker(id, 'Lifetime expired'));\n  }\n  \n  /**\n   * SERVICE WORKER PERSISTENCE BUG FIX: Record security threat\n   */\n  private recordThreat(threat: ServiceWorkerThreat): void {\n    this.threats.push(threat);\n    \n    // Keep only recent threats (last 1000)\n    if (this.threats.length > 1000) {\n      this.threats = this.threats.slice(-1000);\n    }\n    \n    console.warn('Security threat recorded:', threat);\n  }\n  \n  /**\n   * Get security statistics\n   */\n  getSecurityStats(): {\n    activeWorkers: number;\n    totalThreats: number;\n    criticalThreats: number;\n    highThreats: number;\n    mediumThreats: number;\n    lowThreats: number;\n    config: ServiceWorkerSecurityConfig;\n  } {\n    const threatCounts = this.threats.reduce((acc, threat) => {\n      acc[threat.severity]++;\n      return acc;\n    }, { critical: 0, high: 0, medium: 0, low: 0 });\n    \n    return {\n      activeWorkers: this.activeWorkers.size,\n      totalThreats: this.threats.length,\n      criticalThreats: threatCounts.critical,\n      highThreats: threatCounts.high,\n      mediumThreats: threatCounts.medium,\n      lowThreats: threatCounts.low,\n      config: this.config\n    };\n  }\n  \n  /**\n   * Get recent threats\n   */\n  getRecentThreats(limit: number = 50): ServiceWorkerThreat[] {\n    return this.threats.slice(-limit);\n  }\n  \n  /**\n   * Cleanup and shutdown\n   */\n  shutdown(): void {\n    // Clear monitoring interval\n    if (this.monitorInterval) {\n      clearInterval(this.monitorInterval);\n      this.monitorInterval = null;\n    }\n    \n    // Terminate all workers\n    for (const [id] of this.activeWorkers) {\n      this.terminateWorker(id, 'Shutdown');\n    }\n    \n    // Clear threats\n    this.threats = [];\n    \n    console.log('ServiceWorkerProtection shutdown complete');\n  }\n}\n\n// Auto-initialize protection with default settings\nlet autoProtection: ServiceWorkerProtection | null = null;\n\nif (typeof window !== 'undefined') {\n  // Initialize protection on page load\n  if (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', () => {\n      autoProtection = ServiceWorkerProtection.getInstance();\n    });\n  } else {\n    autoProtection = ServiceWorkerProtection.getInstance();\n  }\n  \n  // Cleanup on page unload\n  window.addEventListener('beforeunload', () => {\n    if (autoProtection) {\n      autoProtection.shutdown();\n    }\n  });\n}\n\nexport default ServiceWorkerProtection;