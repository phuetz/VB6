/**
 * Class Builder - Complete VB6 Class Builder Implementation
 * Provides visual design and generation of VB6 classes with properties, methods, and events
 */

import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';

// Class Builder Constants
export enum PropertyType {
  ReadWrite = 'ReadWrite',
  ReadOnly = 'ReadOnly',
  WriteOnly = 'WriteOnly',
}

export enum DataType {
  Boolean = 'Boolean',
  Byte = 'Byte',
  Integer = 'Integer',
  Long = 'Long',
  Single = 'Single',
  Double = 'Double',
  Currency = 'Currency',
  Date = 'Date',
  String = 'String',
  Variant = 'Variant',
  Object = 'Object',
  UserDefined = 'UserDefined',
}

export enum AccessLevel {
  Public = 'Public',
  Private = 'Private',
  Friend = 'Friend',
}

export enum ParameterDirection {
  ByVal = 'ByVal',
  ByRef = 'ByRef',
}

// Class Builder Interfaces
export interface ClassProperty {
  id: string;
  name: string;
  dataType: DataType;
  userDefinedType?: string;
  accessLevel: AccessLevel;
  propertyType: PropertyType;
  description: string;
  defaultValue?: string;
  validation?: string;
  hasDataBinding: boolean;
  bindingDataSource?: string;
  bindingDataField?: string;
  generatePropertyChanged: boolean;
}

export interface MethodParameter {
  id: string;
  name: string;
  dataType: DataType;
  userDefinedType?: string;
  direction: ParameterDirection;
  isOptional: boolean;
  defaultValue?: string;
  description: string;
}

export interface ClassMethod {
  id: string;
  name: string;
  accessLevel: AccessLevel;
  returnType?: DataType;
  userDefinedReturnType?: string;
  description: string;
  parameters: MethodParameter[];
  isFunction: boolean;
  errorHandling: boolean;
  implementation?: string;
}

export interface ClassEvent {
  id: string;
  name: string;
  description: string;
  parameters: MethodParameter[];
}

export interface ClassInfo {
  id: string;
  name: string;
  description: string;
  baseClass?: string;
  implements: string[];
  instancing:
    | 'Private'
    | 'PublicNotCreatable'
    | 'MultiUse'
    | 'GlobalMultiUse'
    | 'SingleUse'
    | 'GlobalSingleUse';
  persistable: boolean;
  properties: ClassProperty[];
  methods: ClassMethod[];
  events: ClassEvent[];
  constants: Array<{
    id: string;
    name: string;
    dataType: DataType;
    value: string;
    description: string;
  }>;
  enums: Array<{
    id: string;
    name: string;
    description: string;
    values: Array<{
      name: string;
      value?: number;
      description: string;
    }>;
  }>;
}

// Class Builder Engine
export class ClassBuilderEngine {
  generateClassCode(classInfo: ClassInfo): string {
    const lines: string[] = [];

    // Class header
    lines.push(`'==========================================`);
    lines.push(`' Class: ${classInfo.name}`);
    if (classInfo.description) {
      lines.push(`' Description: ${classInfo.description}`);
    }
    lines.push(`' Generated by VB6 Class Builder`);
    lines.push(`' Date: ${new Date().toLocaleDateString()}`);
    lines.push(`'==========================================`);
    lines.push('');

    // Attributes
    lines.push(`Attribute VB_Name = "${classInfo.name}"`);
    lines.push(`Attribute VB_GlobalNameSpace = False`);
    lines.push(`Attribute VB_Creatable = ${classInfo.instancing !== 'Private'}`);
    lines.push(`Attribute VB_PredeclaredId = False`);
    lines.push(`Attribute VB_Exposed = ${classInfo.instancing.includes('Public')}`);

    if (classInfo.persistable) {
      lines.push(`Attribute VB_Persistable = True`);
    }

    lines.push('');

    // Option statements
    lines.push('Option Explicit');
    lines.push('');

    // Events
    if (classInfo.events.length > 0) {
      lines.push("'Events");
      classInfo.events.forEach(event => {
        if (event.description) {
          lines.push(`'${event.description}`);
        }
        const params = event.parameters
          .map(
            p =>
              `${p.direction} ${p.name} As ${p.dataType === DataType.UserDefined ? p.userDefinedType : p.dataType}`
          )
          .join(', ');
        lines.push(`Public Event ${event.name}(${params})`);
      });
      lines.push('');
    }

    // Constants
    if (classInfo.constants.length > 0) {
      lines.push("'Constants");
      classInfo.constants.forEach(constant => {
        if (constant.description) {
          lines.push(`'${constant.description}`);
        }
        lines.push(`Private Const ${constant.name} As ${constant.dataType} = ${constant.value}`);
      });
      lines.push('');
    }

    // Enums
    if (classInfo.enums.length > 0) {
      classInfo.enums.forEach(enumDef => {
        if (enumDef.description) {
          lines.push(`'${enumDef.description}`);
        }
        lines.push(`Public Enum ${enumDef.name}`);
        enumDef.values.forEach((value, index) => {
          if (value.description) {
            lines.push(`    '${value.description}`);
          }
          if (value.value !== undefined) {
            lines.push(`    ${value.name} = ${value.value}`);
          } else {
            lines.push(`    ${value.name} = ${index}`);
          }
        });
        lines.push('End Enum');
        lines.push('');
      });
    }

    // Private variables for properties
    const hasProperties = classInfo.properties.length > 0;
    if (hasProperties) {
      lines.push("'Private member variables");
      classInfo.properties.forEach(prop => {
        const dataType =
          prop.dataType === DataType.UserDefined ? prop.userDefinedType : prop.dataType;
        lines.push(`Private m_${prop.name} As ${dataType}`);

        if (prop.hasDataBinding) {
          lines.push(`Private m_${prop.name}_DataSource As Object`);
          lines.push(`Private m_${prop.name}_DataField As String`);
        }
      });
      lines.push('');
    }

    // Class events
    lines.push("'Class Events");
    lines.push('Private Sub Class_Initialize()');
    lines.push("    'Initialize default values");
    classInfo.properties.forEach(prop => {
      if (prop.defaultValue) {
        if (prop.dataType === DataType.String) {
          lines.push(`    m_${prop.name} = "${prop.defaultValue}"`);
        } else {
          lines.push(`    m_${prop.name} = ${prop.defaultValue}`);
        }
      }
    });
    lines.push('End Sub');
    lines.push('');

    lines.push('Private Sub Class_Terminate()');
    lines.push("    'Cleanup resources");
    lines.push('End Sub');
    lines.push('');

    // Properties
    classInfo.properties.forEach(prop => {
      this.generatePropertyCode(lines, prop);
    });

    // Methods
    classInfo.methods.forEach(method => {
      this.generateMethodCode(lines, method);
    });

    // Helper methods
    if (classInfo.properties.some(p => p.generatePropertyChanged)) {
      lines.push("'Property change notification helper");
      lines.push('Private Sub RaisePropertyChanged(PropertyName As String)');
      lines.push('    RaiseEvent PropertyChanged(PropertyName)');
      lines.push('End Sub');
      lines.push('');
    }

    return lines.join('\n');
  }

  private generatePropertyCode(lines: string[], prop: ClassProperty): void {
    const dataType = prop.dataType === DataType.UserDefined ? prop.userDefinedType : prop.dataType;

    // Property header comment
    if (prop.description) {
      lines.push(`'${prop.description}`);
    }

    // Property Get
    if (
      prop.propertyType === PropertyType.ReadWrite ||
      prop.propertyType === PropertyType.ReadOnly
    ) {
      lines.push(`${prop.accessLevel} Property Get ${prop.name}() As ${dataType}`);

      if (prop.hasDataBinding && prop.bindingDataSource) {
        lines.push('    If Not m_' + prop.name + '_DataSource Is Nothing Then');
        lines.push(
          '        ' +
            prop.name +
            ' = m_' +
            prop.name +
            '_DataSource.Fields("' +
            prop.bindingDataField +
            '").Value'
        );
        lines.push('    Else');
        lines.push('        ' + prop.name + ' = m_' + prop.name);
        lines.push('    End If');
      } else {
        lines.push(`    ${prop.name} = m_${prop.name}`);
      }

      lines.push(`End Property`);
      lines.push('');
    }

    // Property Let/Set
    if (
      prop.propertyType === PropertyType.ReadWrite ||
      prop.propertyType === PropertyType.WriteOnly
    ) {
      const isObject = prop.dataType === DataType.Object || prop.dataType === DataType.UserDefined;
      const propType = isObject ? 'Set' : 'Let';

      lines.push(
        `${prop.accessLevel} Property ${propType} ${prop.name}(${propType === 'Set' ? 'ByVal ' : ''}vData As ${dataType})`
      );

      // Validation
      if (prop.validation) {
        lines.push("    'Validation");
        lines.push(`    If Not (${prop.validation.replace('{value}', 'vData')}) Then`);
        lines.push('        Err.Raise 380, , "Invalid property value"');
        lines.push('    End If');
        lines.push('');
      }

      // Assignment
      if (prop.hasDataBinding && prop.bindingDataSource) {
        lines.push('    If Not m_' + prop.name + '_DataSource Is Nothing Then');
        lines.push(
          '        m_' +
            prop.name +
            '_DataSource.Fields("' +
            prop.bindingDataField +
            '").Value = vData'
        );
        lines.push('    End If');
        lines.push('');
      }

      if (isObject) {
        lines.push(`    Set m_${prop.name} = vData`);
      } else {
        lines.push(`    m_${prop.name} = vData`);
      }

      // Property change notification
      if (prop.generatePropertyChanged) {
        lines.push('');
        lines.push("    'Notify property change");
        lines.push(`    RaisePropertyChanged "${prop.name}"`);
      }

      lines.push(`End Property`);
      lines.push('');
    }

    // Data binding methods
    if (prop.hasDataBinding) {
      lines.push(
        `${prop.accessLevel} Sub Bind${prop.name}(DataSource As Object, DataField As String)`
      );
      lines.push(`    Set m_${prop.name}_DataSource = DataSource`);
      lines.push(`    m_${prop.name}_DataField = DataField`);
      lines.push('End Sub');
      lines.push('');
    }
  }

  private generateMethodCode(lines: string[], method: ClassMethod): void {
    // Method header comment
    if (method.description) {
      lines.push(`'${method.description}`);
    }

    // Method signature
    const methodType = method.isFunction ? 'Function' : 'Sub';
    const returnType =
      method.isFunction && method.returnType
        ? ` As ${method.returnType === DataType.UserDefined ? method.userDefinedReturnType : method.returnType}`
        : '';

    const params = method.parameters
      .map(p => {
        const dataType = p.dataType === DataType.UserDefined ? p.userDefinedType : p.dataType;
        let param = `${p.direction} ${p.name} As ${dataType}`;
        if (p.isOptional) {
          param = `Optional ${param}`;
          if (p.defaultValue) {
            param += ` = ${p.defaultValue}`;
          }
        }
        return param;
      })
      .join(', ');

    lines.push(`${method.accessLevel} ${methodType} ${method.name}(${params})${returnType}`);

    // Error handling
    if (method.errorHandling) {
      lines.push('    On Error GoTo ErrorHandler');
      lines.push('');
    }

    // Method body
    if (method.implementation) {
      const implementationLines = method.implementation.split('\n');
      implementationLines.forEach(line => {
        lines.push('    ' + line);
      });
    } else {
      lines.push("    'TODO: Implement method logic");
      if (method.isFunction) {
        lines.push(`    '${method.name} = 'Return value`);
      }
    }

    // Error handling
    if (method.errorHandling) {
      lines.push('');
      lines.push('    Exit ' + methodType);
      lines.push('ErrorHandler:');
      lines.push("    'Handle errors appropriately");
      lines.push('    Err.Raise Err.Number, Err.Source, Err.Description');
    }

    lines.push(`End ${methodType}`);
    lines.push('');
  }

  generateInterfaceCode(
    interfaceName: string,
    methods: ClassMethod[],
    events: ClassEvent[]
  ): string {
    const lines: string[] = [];

    // Interface header
    lines.push(`'==========================================`);
    lines.push(`' Interface: ${interfaceName}`);
    lines.push(`' Generated by VB6 Class Builder`);
    lines.push(`' Date: ${new Date().toLocaleDateString()}`);
    lines.push(`'==========================================`);
    lines.push('');

    lines.push('Option Explicit');
    lines.push('');

    // Events
    events.forEach(event => {
      if (event.description) {
        lines.push(`'${event.description}`);
      }
      const params = event.parameters
        .map(
          p =>
            `${p.direction} ${p.name} As ${p.dataType === DataType.UserDefined ? p.userDefinedType : p.dataType}`
        )
        .join(', ');
      lines.push(`Public Event ${event.name}(${params})`);
    });

    if (events.length > 0) lines.push('');

    // Methods
    methods.forEach(method => {
      if (method.description) {
        lines.push(`'${method.description}`);
      }

      const methodType = method.isFunction ? 'Function' : 'Sub';
      const returnType =
        method.isFunction && method.returnType
          ? ` As ${method.returnType === DataType.UserDefined ? method.userDefinedReturnType : method.returnType}`
          : '';

      const params = method.parameters
        .map(p => {
          const dataType = p.dataType === DataType.UserDefined ? p.userDefinedType : p.dataType;
          let param = `${p.direction} ${p.name} As ${dataType}`;
          if (p.isOptional) {
            param = `Optional ${param}`;
            if (p.defaultValue) {
              param += ` = ${p.defaultValue}`;
            }
          }
          return param;
        })
        .join(', ');

      lines.push(`Public ${methodType} ${method.name}(${params})${returnType}`);
      lines.push(`End ${methodType}`);
      lines.push('');
    });

    return lines.join('\n');
  }

  validateClassName(name: string): string[] {
    const errors: string[] = [];

    if (!name || name.trim().length === 0) {
      errors.push('Class name is required');
    } else {
      if (!/^[a-zA-Z][a-zA-Z0-9_]*$/.test(name)) {
        errors.push(
          'Class name must start with a letter and contain only letters, numbers, and underscores'
        );
      }

      if (name.length > 40) {
        errors.push('Class name cannot exceed 40 characters');
      }

      const reservedWords = [
        'And',
        'As',
        'Boolean',
        'ByRef',
        'Byte',
        'ByVal',
        'Call',
        'Case',
        'Class',
        'Const',
        'Currency',
        'Date',
        'Declare',
        'Dim',
        'Do',
        'Double',
        'Each',
        'Else',
        'ElseIf',
        'End',
        'Enum',
        'Eqv',
        'Error',
        'Exit',
        'False',
        'For',
        'Function',
        'Get',
        'Global',
        'GoSub',
        'GoTo',
        'If',
        'Imp',
        'In',
        'Integer',
        'Is',
        'Let',
        'Like',
        'Long',
        'Loop',
        'Mod',
        'New',
        'Next',
        'Not',
        'Nothing',
        'Object',
        'On',
        'Option',
        'Or',
        'ParamArray',
        'Preserve',
        'Private',
        'Property',
        'Public',
        'ReDim',
        'Resume',
        'Return',
        'Select',
        'Set',
        'Single',
        'Static',
        'Step',
        'Stop',
        'String',
        'Sub',
        'Then',
        'To',
        'True',
        'Type',
        'Until',
        'Variant',
        'Wend',
        'While',
        'With',
        'Xor',
      ];

      if (reservedWords.includes(name)) {
        errors.push('Class name cannot be a VB6 reserved word');
      }
    }

    return errors;
  }

  validatePropertyName(name: string, existingNames: string[]): string[] {
    const errors: string[] = [];

    if (!name || name.trim().length === 0) {
      errors.push('Property name is required');
    } else {
      if (!/^[a-zA-Z][a-zA-Z0-9_]*$/.test(name)) {
        errors.push(
          'Property name must start with a letter and contain only letters, numbers, and underscores'
        );
      }

      if (existingNames.some(existing => existing.toLowerCase() === name.toLowerCase())) {
        errors.push('Property name must be unique within the class');
      }
    }

    return errors;
  }

  validateMethodName(name: string, existingNames: string[]): string[] {
    const errors: string[] = [];

    if (!name || name.trim().length === 0) {
      errors.push('Method name is required');
    } else {
      if (!/^[a-zA-Z][a-zA-Z0-9_]*$/.test(name)) {
        errors.push(
          'Method name must start with a letter and contain only letters, numbers, and underscores'
        );
      }

      if (existingNames.some(existing => existing.toLowerCase() === name.toLowerCase())) {
        errors.push('Method name must be unique within the class');
      }

      const systemMethods = ['Initialize', 'Terminate', 'ReadProperties', 'WriteProperties'];
      if (systemMethods.some(sys => sys.toLowerCase() === name.toLowerCase())) {
        errors.push('Method name conflicts with system method');
      }
    }

    return errors;
  }
}

// Property Designer Component
interface PropertyDesignerProps {
  property?: ClassProperty;
  onSave: (property: ClassProperty) => void;
  onCancel: () => void;
  existingNames: string[];
}

const PropertyDesigner: React.FC<PropertyDesignerProps> = ({
  property,
  onSave,
  onCancel,
  existingNames,
}) => {
  const [formData, setFormData] = useState<ClassProperty>(
    property || {
      id: crypto.randomUUID(),
      name: '',
      dataType: DataType.String,
      accessLevel: AccessLevel.Public,
      propertyType: PropertyType.ReadWrite,
      description: '',
      hasDataBinding: false,
      generatePropertyChanged: false,
    }
  );

  const [errors, setErrors] = useState<string[]>([]);

  const engine = useMemo(() => new ClassBuilderEngine(), []);

  const validateForm = useCallback(() => {
    const nameErrors = engine.validatePropertyName(
      formData.name,
      existingNames.filter(name => name !== property?.name)
    );
    setErrors(nameErrors);
    return nameErrors.length === 0;
  }, [formData.name, existingNames, property?.name, engine]);

  useEffect(() => {
    validateForm();
  }, [formData.name, validateForm]);

  const handleSave = () => {
    if (validateForm()) {
      onSave(formData);
    }
  };

  return (
    <div
      style={{
        position: 'fixed',
        top: '50%',
        left: '50%',
        transform: 'translate(-50%, -50%)',
        width: '500px',
        backgroundColor: 'white',
        border: '2px outset #c0c0c0',
        zIndex: 1000,
        fontFamily: 'MS Sans Serif',
        fontSize: '8pt',
      }}
    >
      <div
        style={{
          backgroundColor: '#008080',
          color: 'white',
          padding: '4px 8px',
          fontWeight: 'bold',
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
        }}
      >
        <span>{property ? 'Edit Property' : 'Add Property'}</span>
        <button
          onClick={onCancel}
          style={{
            backgroundColor: 'transparent',
            border: 'none',
            color: 'white',
            fontSize: '12px',
            cursor: 'pointer',
          }}
        >
          ×
        </button>
      </div>

      <div style={{ padding: '16px' }}>
        {/* Name */}
        <div style={{ marginBottom: '12px' }}>
          <label style={{ display: 'block', marginBottom: '4px', fontWeight: 'bold' }}>Name:</label>
          <input
            type="text"
            value={formData.name}
            onChange={e => setFormData(prev => ({ ...prev, name: e.target.value }))}
            style={{
              width: '100%',
              padding: '2px',
              border: '1px inset #c0c0c0',
              fontFamily: 'MS Sans Serif',
              fontSize: '8pt',
            }}
          />
        </div>

        {/* Data Type */}
        <div style={{ marginBottom: '12px' }}>
          <label style={{ display: 'block', marginBottom: '4px', fontWeight: 'bold' }}>
            Data Type:
          </label>
          <select
            value={formData.dataType}
            onChange={e => setFormData(prev => ({ ...prev, dataType: e.target.value as DataType }))}
            style={{
              width: '200px',
              padding: '2px',
              border: '1px inset #c0c0c0',
              fontFamily: 'MS Sans Serif',
              fontSize: '8pt',
            }}
          >
            {Object.values(DataType).map(type => (
              <option key={type} value={type}>
                {type}
              </option>
            ))}
          </select>

          {formData.dataType === DataType.UserDefined && (
            <input
              type="text"
              placeholder="Type name"
              value={formData.userDefinedType || ''}
              onChange={e => setFormData(prev => ({ ...prev, userDefinedType: e.target.value }))}
              style={{
                marginLeft: '8px',
                width: '150px',
                padding: '2px',
                border: '1px inset #c0c0c0',
              }}
            />
          )}
        </div>

        {/* Access Level */}
        <div style={{ marginBottom: '12px' }}>
          <label style={{ display: 'block', marginBottom: '4px', fontWeight: 'bold' }}>
            Access Level:
          </label>
          <div>
            {Object.values(AccessLevel).map(level => (
              <label key={level} style={{ marginRight: '16px' }}>
                <input
                  type="radio"
                  name="accessLevel"
                  value={level}
                  checked={formData.accessLevel === level}
                  onChange={e =>
                    setFormData(prev => ({ ...prev, accessLevel: e.target.value as AccessLevel }))
                  }
                />
                {level}
              </label>
            ))}
          </div>
        </div>

        {/* Property Type */}
        <div style={{ marginBottom: '12px' }}>
          <label style={{ display: 'block', marginBottom: '4px', fontWeight: 'bold' }}>
            Property Type:
          </label>
          <div>
            {Object.values(PropertyType).map(type => (
              <label key={type} style={{ marginRight: '16px' }}>
                <input
                  type="radio"
                  name="propertyType"
                  value={type}
                  checked={formData.propertyType === type}
                  onChange={e =>
                    setFormData(prev => ({ ...prev, propertyType: e.target.value as PropertyType }))
                  }
                />
                {type}
              </label>
            ))}
          </div>
        </div>

        {/* Description */}
        <div style={{ marginBottom: '12px' }}>
          <label style={{ display: 'block', marginBottom: '4px', fontWeight: 'bold' }}>
            Description:
          </label>
          <textarea
            value={formData.description}
            onChange={e => setFormData(prev => ({ ...prev, description: e.target.value }))}
            rows={3}
            style={{
              width: '100%',
              padding: '2px',
              border: '1px inset #c0c0c0',
              fontFamily: 'MS Sans Serif',
              fontSize: '8pt',
              resize: 'vertical',
            }}
          />
        </div>

        {/* Default Value */}
        <div style={{ marginBottom: '12px' }}>
          <label style={{ display: 'block', marginBottom: '4px', fontWeight: 'bold' }}>
            Default Value:
          </label>
          <input
            type="text"
            value={formData.defaultValue || ''}
            onChange={e => setFormData(prev => ({ ...prev, defaultValue: e.target.value }))}
            style={{
              width: '100%',
              padding: '2px',
              border: '1px inset #c0c0c0',
              fontFamily: 'MS Sans Serif',
              fontSize: '8pt',
            }}
          />
        </div>

        {/* Options */}
        <div style={{ marginBottom: '12px' }}>
          <label>
            <input
              type="checkbox"
              checked={formData.hasDataBinding}
              onChange={e => setFormData(prev => ({ ...prev, hasDataBinding: e.target.checked }))}
            />
            Enable Data Binding
          </label>
        </div>

        <div style={{ marginBottom: '12px' }}>
          <label>
            <input
              type="checkbox"
              checked={formData.generatePropertyChanged}
              onChange={e =>
                setFormData(prev => ({ ...prev, generatePropertyChanged: e.target.checked }))
              }
            />
            Generate PropertyChanged Event
          </label>
        </div>

        {/* Errors */}
        {errors.length > 0 && (
          <div
            style={{
              backgroundColor: '#ffe0e0',
              border: '1px solid #ff0000',
              padding: '8px',
              marginBottom: '12px',
              fontSize: '8pt',
            }}
          >
            {errors.map((error, index) => (
              <div key={index} style={{ color: '#cc0000' }}>
                {error}
              </div>
            ))}
          </div>
        )}

        {/* Buttons */}
        <div
          style={{ textAlign: 'right', display: 'flex', gap: '8px', justifyContent: 'flex-end' }}
        >
          <button
            onClick={handleSave}
            disabled={errors.length > 0}
            style={{
              padding: '4px 16px',
              border: '1px outset #c0c0c0',
              backgroundColor: errors.length > 0 ? '#f0f0f0' : 'white',
              cursor: errors.length > 0 ? 'not-allowed' : 'pointer',
              fontFamily: 'MS Sans Serif',
              fontSize: '8pt',
            }}
          >
            OK
          </button>
          <button
            onClick={onCancel}
            style={{
              padding: '4px 16px',
              border: '1px outset #c0c0c0',
              backgroundColor: 'white',
              cursor: 'pointer',
              fontFamily: 'MS Sans Serif',
              fontSize: '8pt',
            }}
          >
            Cancel
          </button>
        </div>
      </div>
    </div>
  );
};

// Method Designer Component
interface MethodDesignerProps {
  method?: ClassMethod;
  onSave: (method: ClassMethod) => void;
  onCancel: () => void;
  existingNames: string[];
}

const MethodDesigner: React.FC<MethodDesignerProps> = ({
  method,
  onSave,
  onCancel,
  existingNames,
}) => {
  const [formData, setFormData] = useState<ClassMethod>(
    method || {
      id: crypto.randomUUID(),
      name: '',
      accessLevel: AccessLevel.Public,
      description: '',
      parameters: [],
      isFunction: false,
      errorHandling: true,
    }
  );

  const [errors, setErrors] = useState<string[]>([]);
  const [editingParameter, setEditingParameter] = useState<MethodParameter | null>(null);

  const engine = useMemo(() => new ClassBuilderEngine(), []);

  const validateForm = useCallback(() => {
    const nameErrors = engine.validateMethodName(
      formData.name,
      existingNames.filter(name => name !== method?.name)
    );
    setErrors(nameErrors);
    return nameErrors.length === 0;
  }, [formData.name, existingNames, method?.name, engine]);

  useEffect(() => {
    validateForm();
  }, [formData.name, validateForm]);

  const handleSave = () => {
    if (validateForm()) {
      onSave(formData);
    }
  };

  const addParameter = () => {
    setEditingParameter({
      id: crypto.randomUUID(),
      name: '',
      dataType: DataType.String,
      direction: ParameterDirection.ByVal,
      isOptional: false,
      description: '',
    });
  };

  const editParameter = (param: MethodParameter) => {
    setEditingParameter({ ...param });
  };

  const saveParameter = (param: MethodParameter) => {
    const existingIndex = formData.parameters.findIndex(p => p.id === param.id);
    if (existingIndex >= 0) {
      const newParams = [...formData.parameters];
      newParams[existingIndex] = param;
      setFormData(prev => ({ ...prev, parameters: newParams }));
    } else {
      setFormData(prev => ({ ...prev, parameters: [...prev.parameters, param] }));
    }
    setEditingParameter(null);
  };

  const deleteParameter = (id: string) => {
    setFormData(prev => ({
      ...prev,
      parameters: prev.parameters.filter(p => p.id !== id),
    }));
  };

  return (
    <div
      style={{
        position: 'fixed',
        top: '50%',
        left: '50%',
        transform: 'translate(-50%, -50%)',
        width: '600px',
        height: '500px',
        backgroundColor: 'white',
        border: '2px outset #c0c0c0',
        zIndex: 1000,
        fontFamily: 'MS Sans Serif',
        fontSize: '8pt',
        display: 'flex',
        flexDirection: 'column',
      }}
    >
      <div
        style={{
          backgroundColor: '#008080',
          color: 'white',
          padding: '4px 8px',
          fontWeight: 'bold',
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
        }}
      >
        <span>{method ? 'Edit Method' : 'Add Method'}</span>
        <button
          onClick={onCancel}
          style={{
            backgroundColor: 'transparent',
            border: 'none',
            color: 'white',
            fontSize: '12px',
            cursor: 'pointer',
          }}
        >
          ×
        </button>
      </div>

      <div style={{ padding: '16px', flex: 1, overflow: 'auto' }}>
        {/* Name */}
        <div style={{ marginBottom: '12px' }}>
          <label style={{ display: 'block', marginBottom: '4px', fontWeight: 'bold' }}>Name:</label>
          <input
            type="text"
            value={formData.name}
            onChange={e => setFormData(prev => ({ ...prev, name: e.target.value }))}
            style={{
              width: '200px',
              padding: '2px',
              border: '1px inset #c0c0c0',
              fontFamily: 'MS Sans Serif',
              fontSize: '8pt',
            }}
          />
        </div>

        {/* Method Type */}
        <div style={{ marginBottom: '12px' }}>
          <label style={{ marginRight: '16px' }}>
            <input
              type="radio"
              name="methodType"
              checked={!formData.isFunction}
              onChange={() =>
                setFormData(prev => ({ ...prev, isFunction: false, returnType: undefined }))
              }
            />
            Subroutine
          </label>
          <label>
            <input
              type="radio"
              name="methodType"
              checked={formData.isFunction}
              onChange={() =>
                setFormData(prev => ({ ...prev, isFunction: true, returnType: DataType.String }))
              }
            />
            Function
          </label>
        </div>

        {/* Return Type */}
        {formData.isFunction && (
          <div style={{ marginBottom: '12px' }}>
            <label style={{ display: 'block', marginBottom: '4px', fontWeight: 'bold' }}>
              Return Type:
            </label>
            <select
              value={formData.returnType || DataType.String}
              onChange={e =>
                setFormData(prev => ({ ...prev, returnType: e.target.value as DataType }))
              }
              style={{
                width: '200px',
                padding: '2px',
                border: '1px inset #c0c0c0',
                fontFamily: 'MS Sans Serif',
                fontSize: '8pt',
              }}
            >
              {Object.values(DataType).map(type => (
                <option key={type} value={type}>
                  {type}
                </option>
              ))}
            </select>
          </div>
        )}

        {/* Access Level */}
        <div style={{ marginBottom: '12px' }}>
          <label style={{ display: 'block', marginBottom: '4px', fontWeight: 'bold' }}>
            Access Level:
          </label>
          <div>
            {Object.values(AccessLevel).map(level => (
              <label key={level} style={{ marginRight: '16px' }}>
                <input
                  type="radio"
                  name="accessLevel"
                  value={level}
                  checked={formData.accessLevel === level}
                  onChange={e =>
                    setFormData(prev => ({ ...prev, accessLevel: e.target.value as AccessLevel }))
                  }
                />
                {level}
              </label>
            ))}
          </div>
        </div>

        {/* Description */}
        <div style={{ marginBottom: '12px' }}>
          <label style={{ display: 'block', marginBottom: '4px', fontWeight: 'bold' }}>
            Description:
          </label>
          <textarea
            value={formData.description}
            onChange={e => setFormData(prev => ({ ...prev, description: e.target.value }))}
            rows={2}
            style={{
              width: '100%',
              padding: '2px',
              border: '1px inset #c0c0c0',
              fontFamily: 'MS Sans Serif',
              fontSize: '8pt',
              resize: 'vertical',
            }}
          />
        </div>

        {/* Parameters */}
        <div style={{ marginBottom: '12px' }}>
          <div
            style={{
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'center',
              marginBottom: '8px',
            }}
          >
            <label style={{ fontWeight: 'bold' }}>Parameters:</label>
            <button
              onClick={addParameter}
              style={{
                padding: '2px 8px',
                border: '1px outset #c0c0c0',
                backgroundColor: 'white',
                cursor: 'pointer',
                fontSize: '8pt',
              }}
            >
              Add
            </button>
          </div>

          <div
            style={{
              border: '1px inset #c0c0c0',
              height: '150px',
              overflow: 'auto',
              backgroundColor: 'white',
            }}
          >
            {formData.parameters.length === 0 ? (
              <div style={{ padding: '8px', color: '#999', textAlign: 'center' }}>
                No parameters defined
              </div>
            ) : (
              <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '8pt' }}>
                <thead>
                  <tr style={{ backgroundColor: '#f0f0f0' }}>
                    <th style={{ border: '1px solid #ccc', padding: '2px', textAlign: 'left' }}>
                      Name
                    </th>
                    <th style={{ border: '1px solid #ccc', padding: '2px', textAlign: 'left' }}>
                      Type
                    </th>
                    <th style={{ border: '1px solid #ccc', padding: '2px', textAlign: 'left' }}>
                      Direction
                    </th>
                    <th style={{ border: '1px solid #ccc', padding: '2px', textAlign: 'left' }}>
                      Optional
                    </th>
                    <th style={{ border: '1px solid #ccc', padding: '2px', textAlign: 'left' }}>
                      Actions
                    </th>
                  </tr>
                </thead>
                <tbody>
                  {formData.parameters.map(param => (
                    <tr key={param.id}>
                      <td style={{ border: '1px solid #ccc', padding: '2px' }}>{param.name}</td>
                      <td style={{ border: '1px solid #ccc', padding: '2px' }}>
                        {param.dataType === DataType.UserDefined
                          ? param.userDefinedType
                          : param.dataType}
                      </td>
                      <td style={{ border: '1px solid #ccc', padding: '2px' }}>
                        {param.direction}
                      </td>
                      <td style={{ border: '1px solid #ccc', padding: '2px' }}>
                        {param.isOptional ? 'Yes' : 'No'}
                      </td>
                      <td style={{ border: '1px solid #ccc', padding: '2px' }}>
                        <button
                          onClick={() => editParameter(param)}
                          style={{ fontSize: '8pt', marginRight: '4px' }}
                        >
                          Edit
                        </button>
                        <button
                          onClick={() => deleteParameter(param.id)}
                          style={{ fontSize: '8pt' }}
                        >
                          Delete
                        </button>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            )}
          </div>
        </div>

        {/* Options */}
        <div style={{ marginBottom: '12px' }}>
          <label>
            <input
              type="checkbox"
              checked={formData.errorHandling}
              onChange={e => setFormData(prev => ({ ...prev, errorHandling: e.target.checked }))}
            />
            Generate Error Handling Code
          </label>
        </div>

        {/* Errors */}
        {errors.length > 0 && (
          <div
            style={{
              backgroundColor: '#ffe0e0',
              border: '1px solid #ff0000',
              padding: '8px',
              marginBottom: '12px',
              fontSize: '8pt',
            }}
          >
            {errors.map((error, index) => (
              <div key={index} style={{ color: '#cc0000' }}>
                {error}
              </div>
            ))}
          </div>
        )}
      </div>

      {/* Buttons */}
      <div
        style={{
          padding: '8px 16px',
          borderTop: '1px solid #ccc',
          textAlign: 'right',
          display: 'flex',
          gap: '8px',
          justifyContent: 'flex-end',
        }}
      >
        <button
          onClick={handleSave}
          disabled={errors.length > 0}
          style={{
            padding: '4px 16px',
            border: '1px outset #c0c0c0',
            backgroundColor: errors.length > 0 ? '#f0f0f0' : 'white',
            cursor: errors.length > 0 ? 'not-allowed' : 'pointer',
            fontFamily: 'MS Sans Serif',
            fontSize: '8pt',
          }}
        >
          OK
        </button>
        <button
          onClick={onCancel}
          style={{
            padding: '4px 16px',
            border: '1px outset #c0c0c0',
            backgroundColor: 'white',
            cursor: 'pointer',
            fontFamily: 'MS Sans Serif',
            fontSize: '8pt',
          }}
        >
          Cancel
        </button>
      </div>

      {/* Parameter Editor */}
      {editingParameter && (
        <ParameterEditor
          parameter={editingParameter}
          onSave={saveParameter}
          onCancel={() => setEditingParameter(null)}
        />
      )}
    </div>
  );
};

// Parameter Editor Component
interface ParameterEditorProps {
  parameter: MethodParameter;
  onSave: (parameter: MethodParameter) => void;
  onCancel: () => void;
}

const ParameterEditor: React.FC<ParameterEditorProps> = ({ parameter, onSave, onCancel }) => {
  const [formData, setFormData] = useState<MethodParameter>(parameter);

  const handleSave = () => {
    if (formData.name.trim()) {
      onSave(formData);
    }
  };

  return (
    <div
      style={{
        position: 'fixed',
        top: '50%',
        left: '50%',
        transform: 'translate(-50%, -50%)',
        width: '400px',
        backgroundColor: 'white',
        border: '2px outset #c0c0c0',
        zIndex: 1001,
        fontFamily: 'MS Sans Serif',
        fontSize: '8pt',
      }}
    >
      <div
        style={{
          backgroundColor: '#008080',
          color: 'white',
          padding: '4px 8px',
          fontWeight: 'bold',
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
        }}
      >
        <span>Parameter Properties</span>
        <button
          onClick={onCancel}
          style={{
            backgroundColor: 'transparent',
            border: 'none',
            color: 'white',
            fontSize: '12px',
            cursor: 'pointer',
          }}
        >
          ×
        </button>
      </div>

      <div style={{ padding: '16px' }}>
        {/* Name */}
        <div style={{ marginBottom: '12px' }}>
          <label style={{ display: 'block', marginBottom: '4px', fontWeight: 'bold' }}>Name:</label>
          <input
            type="text"
            value={formData.name}
            onChange={e => setFormData(prev => ({ ...prev, name: e.target.value }))}
            style={{
              width: '100%',
              padding: '2px',
              border: '1px inset #c0c0c0',
              fontFamily: 'MS Sans Serif',
              fontSize: '8pt',
            }}
          />
        </div>

        {/* Data Type */}
        <div style={{ marginBottom: '12px' }}>
          <label style={{ display: 'block', marginBottom: '4px', fontWeight: 'bold' }}>
            Data Type:
          </label>
          <select
            value={formData.dataType}
            onChange={e => setFormData(prev => ({ ...prev, dataType: e.target.value as DataType }))}
            style={{
              width: '150px',
              padding: '2px',
              border: '1px inset #c0c0c0',
              fontFamily: 'MS Sans Serif',
              fontSize: '8pt',
            }}
          >
            {Object.values(DataType).map(type => (
              <option key={type} value={type}>
                {type}
              </option>
            ))}
          </select>
        </div>

        {/* Direction */}
        <div style={{ marginBottom: '12px' }}>
          <label style={{ display: 'block', marginBottom: '4px', fontWeight: 'bold' }}>
            Direction:
          </label>
          <div>
            {Object.values(ParameterDirection).map(dir => (
              <label key={dir} style={{ marginRight: '16px' }}>
                <input
                  type="radio"
                  name="direction"
                  value={dir}
                  checked={formData.direction === dir}
                  onChange={e =>
                    setFormData(prev => ({
                      ...prev,
                      direction: e.target.value as ParameterDirection,
                    }))
                  }
                />
                {dir}
              </label>
            ))}
          </div>
        </div>

        {/* Optional */}
        <div style={{ marginBottom: '12px' }}>
          <label>
            <input
              type="checkbox"
              checked={formData.isOptional}
              onChange={e => setFormData(prev => ({ ...prev, isOptional: e.target.checked }))}
            />
            Optional Parameter
          </label>
        </div>

        {/* Default Value */}
        {formData.isOptional && (
          <div style={{ marginBottom: '12px' }}>
            <label style={{ display: 'block', marginBottom: '4px', fontWeight: 'bold' }}>
              Default Value:
            </label>
            <input
              type="text"
              value={formData.defaultValue || ''}
              onChange={e => setFormData(prev => ({ ...prev, defaultValue: e.target.value }))}
              style={{
                width: '100%',
                padding: '2px',
                border: '1px inset #c0c0c0',
                fontFamily: 'MS Sans Serif',
                fontSize: '8pt',
              }}
            />
          </div>
        )}

        {/* Description */}
        <div style={{ marginBottom: '12px' }}>
          <label style={{ display: 'block', marginBottom: '4px', fontWeight: 'bold' }}>
            Description:
          </label>
          <textarea
            value={formData.description}
            onChange={e => setFormData(prev => ({ ...prev, description: e.target.value }))}
            rows={3}
            style={{
              width: '100%',
              padding: '2px',
              border: '1px inset #c0c0c0',
              fontFamily: 'MS Sans Serif',
              fontSize: '8pt',
              resize: 'vertical',
            }}
          />
        </div>

        {/* Buttons */}
        <div
          style={{ textAlign: 'right', display: 'flex', gap: '8px', justifyContent: 'flex-end' }}
        >
          <button
            onClick={handleSave}
            disabled={!formData.name.trim()}
            style={{
              padding: '4px 16px',
              border: '1px outset #c0c0c0',
              backgroundColor: !formData.name.trim() ? '#f0f0f0' : 'white',
              cursor: !formData.name.trim() ? 'not-allowed' : 'pointer',
              fontFamily: 'MS Sans Serif',
              fontSize: '8pt',
            }}
          >
            OK
          </button>
          <button
            onClick={onCancel}
            style={{
              padding: '4px 16px',
              border: '1px outset #c0c0c0',
              backgroundColor: 'white',
              cursor: 'pointer',
              fontFamily: 'MS Sans Serif',
              fontSize: '8pt',
            }}
          >
            Cancel
          </button>
        </div>
      </div>
    </div>
  );
};

// Main Class Builder Component
export interface ClassBuilderProps {
  onSaveClass?: (classInfo: ClassInfo) => void;
  onGenerateCode?: (code: string) => void;
  initialClass?: ClassInfo;
}

export const ClassBuilder: React.FC<ClassBuilderProps> = ({
  onSaveClass,
  onGenerateCode,
  initialClass,
}) => {
  const [classInfo, setClassInfo] = useState<ClassInfo>(
    initialClass || {
      id: crypto.randomUUID(),
      name: 'MyClass',
      description: '',
      implements: [],
      instancing: 'MultiUse',
      persistable: false,
      properties: [],
      methods: [],
      events: [],
      constants: [],
      enums: [],
    }
  );

  const [activeTab, setActiveTab] = useState<
    'general' | 'properties' | 'methods' | 'events' | 'code'
  >('general');
  const [editingProperty, setEditingProperty] = useState<ClassProperty | undefined>();
  const [editingMethod, setEditingMethod] = useState<ClassMethod | undefined>();
  const [showPropertyDesigner, setShowPropertyDesigner] = useState(false);
  const [showMethodDesigner, setShowMethodDesigner] = useState(false);
  const [generatedCode, setGeneratedCode] = useState('');

  const engine = useMemo(() => new ClassBuilderEngine(), []);

  const generateCode = useCallback(() => {
    const code = engine.generateClassCode(classInfo);
    setGeneratedCode(code);
    onGenerateCode?.(code);
  }, [classInfo, engine, onGenerateCode]);

  useEffect(() => {
    generateCode();
  }, [generateCode]);

  const addProperty = () => {
    setEditingProperty(undefined);
    setShowPropertyDesigner(true);
  };

  const editProperty = (property: ClassProperty) => {
    setEditingProperty(property);
    setShowPropertyDesigner(true);
  };

  const saveProperty = (property: ClassProperty) => {
    const existingIndex = classInfo.properties.findIndex(p => p.id === property.id);
    if (existingIndex >= 0) {
      const newProperties = [...classInfo.properties];
      newProperties[existingIndex] = property;
      setClassInfo(prev => ({ ...prev, properties: newProperties }));
    } else {
      setClassInfo(prev => ({ ...prev, properties: [...prev.properties, property] }));
    }
    setShowPropertyDesigner(false);
    setEditingProperty(undefined);
  };

  const deleteProperty = (id: string) => {
    setClassInfo(prev => ({
      ...prev,
      properties: prev.properties.filter(p => p.id !== id),
    }));
  };

  const addMethod = () => {
    setEditingMethod(undefined);
    setShowMethodDesigner(true);
  };

  const editMethod = (method: ClassMethod) => {
    setEditingMethod(method);
    setShowMethodDesigner(true);
  };

  const saveMethod = (method: ClassMethod) => {
    const existingIndex = classInfo.methods.findIndex(m => m.id === method.id);
    if (existingIndex >= 0) {
      const newMethods = [...classInfo.methods];
      newMethods[existingIndex] = method;
      setClassInfo(prev => ({ ...prev, methods: newMethods }));
    } else {
      setClassInfo(prev => ({ ...prev, methods: [...prev.methods, method] }));
    }
    setShowMethodDesigner(false);
    setEditingMethod(undefined);
  };

  const deleteMethod = (id: string) => {
    setClassInfo(prev => ({
      ...prev,
      methods: prev.methods.filter(m => m.id !== id),
    }));
  };

  const existingPropertyNames = classInfo.properties.map(p => p.name);
  const existingMethodNames = classInfo.methods.map(m => m.name);

  return (
    <div
      style={{
        width: '100%',
        height: '100%',
        display: 'flex',
        flexDirection: 'column',
        fontFamily: 'MS Sans Serif',
        fontSize: '8pt',
        backgroundColor: '#f0f0f0',
      }}
    >
      {/* Title Bar */}
      <div
        style={{
          backgroundColor: '#008080',
          color: 'white',
          padding: '4px 8px',
          fontWeight: 'bold',
          fontSize: '9pt',
        }}
      >
        Class Builder - {classInfo.name}
      </div>

      {/* Toolbar */}
      <div
        style={{
          padding: '4px 8px',
          borderBottom: '1px solid #ccc',
          backgroundColor: '#e0e0e0',
          display: 'flex',
          gap: '8px',
        }}
      >
        <button
          onClick={() => onSaveClass?.(classInfo)}
          style={{
            padding: '4px 12px',
            border: '1px outset #c0c0c0',
            backgroundColor: 'white',
            cursor: 'pointer',
            fontSize: '8pt',
          }}
        >
          Save Class
        </button>

        <button
          onClick={generateCode}
          style={{
            padding: '4px 12px',
            border: '1px outset #c0c0c0',
            backgroundColor: 'white',
            cursor: 'pointer',
            fontSize: '8pt',
          }}
        >
          Generate Code
        </button>

        <button
          onClick={() => {
            navigator.clipboard.writeText(generatedCode);
          }}
          style={{
            padding: '4px 12px',
            border: '1px outset #c0c0c0',
            backgroundColor: 'white',
            cursor: 'pointer',
            fontSize: '8pt',
          }}
        >
          Copy Code
        </button>
      </div>

      {/* Tab Bar */}
      <div
        style={{
          display: 'flex',
          borderBottom: '1px solid #ccc',
          backgroundColor: '#e0e0e0',
        }}
      >
        {[
          { key: 'general', label: 'General' },
          { key: 'properties', label: 'Properties' },
          { key: 'methods', label: 'Methods' },
          { key: 'events', label: 'Events' },
          { key: 'code', label: 'Generated Code' },
        ].map(tab => (
          <button
            key={tab.key}
            onClick={() => setActiveTab(tab.key as any)}
            style={{
              padding: '6px 16px',
              border: 'none',
              backgroundColor: activeTab === tab.key ? 'white' : 'transparent',
              borderTop: activeTab === tab.key ? '2px solid #008080' : '2px solid transparent',
              cursor: 'pointer',
              fontSize: '8pt',
              borderBottom: activeTab === tab.key ? '1px solid white' : '1px solid #ccc',
            }}
          >
            {tab.label}
          </button>
        ))}
      </div>

      {/* Content Area */}
      <div style={{ flex: 1, padding: '16px', overflow: 'auto', backgroundColor: 'white' }}>
        {activeTab === 'general' && (
          <div>
            <h3 style={{ margin: '0 0 16px 0', color: '#008080' }}>General Settings</h3>

            {/* Class Name */}
            <div style={{ marginBottom: '16px' }}>
              <label style={{ display: 'block', marginBottom: '4px', fontWeight: 'bold' }}>
                Class Name:
              </label>
              <input
                type="text"
                value={classInfo.name}
                onChange={e => setClassInfo(prev => ({ ...prev, name: e.target.value }))}
                style={{
                  width: '200px',
                  padding: '4px',
                  border: '1px inset #c0c0c0',
                  fontSize: '8pt',
                }}
              />
            </div>

            {/* Description */}
            <div style={{ marginBottom: '16px' }}>
              <label style={{ display: 'block', marginBottom: '4px', fontWeight: 'bold' }}>
                Description:
              </label>
              <textarea
                value={classInfo.description}
                onChange={e => setClassInfo(prev => ({ ...prev, description: e.target.value }))}
                rows={4}
                style={{
                  width: '400px',
                  padding: '4px',
                  border: '1px inset #c0c0c0',
                  fontSize: '8pt',
                  resize: 'vertical',
                }}
              />
            </div>

            {/* Instancing */}
            <div style={{ marginBottom: '16px' }}>
              <label style={{ display: 'block', marginBottom: '4px', fontWeight: 'bold' }}>
                Instancing:
              </label>
              <select
                value={classInfo.instancing}
                onChange={e =>
                  setClassInfo(prev => ({ ...prev, instancing: e.target.value as any }))
                }
                style={{
                  width: '200px',
                  padding: '4px',
                  border: '1px inset #c0c0c0',
                  fontSize: '8pt',
                }}
              >
                <option value="Private">Private</option>
                <option value="PublicNotCreatable">PublicNotCreatable</option>
                <option value="MultiUse">MultiUse</option>
                <option value="GlobalMultiUse">GlobalMultiUse</option>
                <option value="SingleUse">SingleUse</option>
                <option value="GlobalSingleUse">GlobalSingleUse</option>
              </select>
            </div>

            {/* Options */}
            <div style={{ marginBottom: '16px' }}>
              <label>
                <input
                  type="checkbox"
                  checked={classInfo.persistable}
                  onChange={e => setClassInfo(prev => ({ ...prev, persistable: e.target.checked }))}
                />
                Persistable
              </label>
            </div>

            {/* Summary */}
            <div
              style={{
                border: '1px solid #ccc',
                padding: '12px',
                backgroundColor: '#f8f8f8',
                marginTop: '24px',
              }}
            >
              <h4 style={{ margin: '0 0 8px 0' }}>Class Summary</h4>
              <div>Properties: {classInfo.properties.length}</div>
              <div>Methods: {classInfo.methods.length}</div>
              <div>Events: {classInfo.events.length}</div>
              <div>Constants: {classInfo.constants.length}</div>
              <div>Enums: {classInfo.enums.length}</div>
            </div>
          </div>
        )}

        {activeTab === 'properties' && (
          <div>
            <div
              style={{
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                marginBottom: '16px',
              }}
            >
              <h3 style={{ margin: 0, color: '#008080' }}>Properties</h3>
              <button
                onClick={addProperty}
                style={{
                  padding: '4px 12px',
                  border: '1px outset #c0c0c0',
                  backgroundColor: 'white',
                  cursor: 'pointer',
                  fontSize: '8pt',
                }}
              >
                Add Property
              </button>
            </div>

            {classInfo.properties.length === 0 ? (
              <div style={{ textAlign: 'center', color: '#999', marginTop: '40px' }}>
                No properties defined. Click "Add Property" to create one.
              </div>
            ) : (
              <div style={{ border: '1px solid #ccc', backgroundColor: 'white' }}>
                <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '8pt' }}>
                  <thead>
                    <tr style={{ backgroundColor: '#f0f0f0' }}>
                      <th style={{ border: '1px solid #ccc', padding: '4px', textAlign: 'left' }}>
                        Name
                      </th>
                      <th style={{ border: '1px solid #ccc', padding: '4px', textAlign: 'left' }}>
                        Type
                      </th>
                      <th style={{ border: '1px solid #ccc', padding: '4px', textAlign: 'left' }}>
                        Access
                      </th>
                      <th style={{ border: '1px solid #ccc', padding: '4px', textAlign: 'left' }}>
                        Property Type
                      </th>
                      <th style={{ border: '1px solid #ccc', padding: '4px', textAlign: 'left' }}>
                        Description
                      </th>
                      <th style={{ border: '1px solid #ccc', padding: '4px', textAlign: 'left' }}>
                        Actions
                      </th>
                    </tr>
                  </thead>
                  <tbody>
                    {classInfo.properties.map(prop => (
                      <tr key={prop.id}>
                        <td
                          style={{ border: '1px solid #ccc', padding: '4px', fontWeight: 'bold' }}
                        >
                          {prop.name}
                        </td>
                        <td style={{ border: '1px solid #ccc', padding: '4px' }}>
                          {prop.dataType === DataType.UserDefined
                            ? prop.userDefinedType
                            : prop.dataType}
                        </td>
                        <td style={{ border: '1px solid #ccc', padding: '4px' }}>
                          {prop.accessLevel}
                        </td>
                        <td style={{ border: '1px solid #ccc', padding: '4px' }}>
                          {prop.propertyType}
                        </td>
                        <td style={{ border: '1px solid #ccc', padding: '4px' }}>
                          {prop.description}
                        </td>
                        <td style={{ border: '1px solid #ccc', padding: '4px' }}>
                          <button
                            onClick={() => editProperty(prop)}
                            style={{ fontSize: '8pt', marginRight: '4px' }}
                          >
                            Edit
                          </button>
                          <button
                            onClick={() => deleteProperty(prop.id)}
                            style={{ fontSize: '8pt' }}
                          >
                            Delete
                          </button>
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            )}
          </div>
        )}

        {activeTab === 'methods' && (
          <div>
            <div
              style={{
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                marginBottom: '16px',
              }}
            >
              <h3 style={{ margin: 0, color: '#008080' }}>Methods</h3>
              <button
                onClick={addMethod}
                style={{
                  padding: '4px 12px',
                  border: '1px outset #c0c0c0',
                  backgroundColor: 'white',
                  cursor: 'pointer',
                  fontSize: '8pt',
                }}
              >
                Add Method
              </button>
            </div>

            {classInfo.methods.length === 0 ? (
              <div style={{ textAlign: 'center', color: '#999', marginTop: '40px' }}>
                No methods defined. Click "Add Method" to create one.
              </div>
            ) : (
              <div style={{ border: '1px solid #ccc', backgroundColor: 'white' }}>
                <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '8pt' }}>
                  <thead>
                    <tr style={{ backgroundColor: '#f0f0f0' }}>
                      <th style={{ border: '1px solid #ccc', padding: '4px', textAlign: 'left' }}>
                        Name
                      </th>
                      <th style={{ border: '1px solid #ccc', padding: '4px', textAlign: 'left' }}>
                        Type
                      </th>
                      <th style={{ border: '1px solid #ccc', padding: '4px', textAlign: 'left' }}>
                        Access
                      </th>
                      <th style={{ border: '1px solid #ccc', padding: '4px', textAlign: 'left' }}>
                        Parameters
                      </th>
                      <th style={{ border: '1px solid #ccc', padding: '4px', textAlign: 'left' }}>
                        Description
                      </th>
                      <th style={{ border: '1px solid #ccc', padding: '4px', textAlign: 'left' }}>
                        Actions
                      </th>
                    </tr>
                  </thead>
                  <tbody>
                    {classInfo.methods.map(method => (
                      <tr key={method.id}>
                        <td
                          style={{ border: '1px solid #ccc', padding: '4px', fontWeight: 'bold' }}
                        >
                          {method.name}
                        </td>
                        <td style={{ border: '1px solid #ccc', padding: '4px' }}>
                          {method.isFunction ? 'Function' : 'Subroutine'}
                          {method.isFunction && method.returnType && ` (${method.returnType})`}
                        </td>
                        <td style={{ border: '1px solid #ccc', padding: '4px' }}>
                          {method.accessLevel}
                        </td>
                        <td style={{ border: '1px solid #ccc', padding: '4px' }}>
                          {method.parameters.length}
                        </td>
                        <td style={{ border: '1px solid #ccc', padding: '4px' }}>
                          {method.description}
                        </td>
                        <td style={{ border: '1px solid #ccc', padding: '4px' }}>
                          <button
                            onClick={() => editMethod(method)}
                            style={{ fontSize: '8pt', marginRight: '4px' }}
                          >
                            Edit
                          </button>
                          <button
                            onClick={() => deleteMethod(method.id)}
                            style={{ fontSize: '8pt' }}
                          >
                            Delete
                          </button>
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            )}
          </div>
        )}

        {activeTab === 'events' && (
          <div>
            <div
              style={{
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                marginBottom: '16px',
              }}
            >
              <h3 style={{ margin: 0, color: '#008080' }}>Events</h3>
              <button
                style={{
                  padding: '4px 12px',
                  border: '1px outset #c0c0c0',
                  backgroundColor: 'white',
                  cursor: 'pointer',
                  fontSize: '8pt',
                }}
              >
                Add Event
              </button>
            </div>

            <div style={{ textAlign: 'center', color: '#999', marginTop: '40px' }}>
              Event designer coming soon...
            </div>
          </div>
        )}

        {activeTab === 'code' && (
          <div>
            <div
              style={{
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                marginBottom: '16px',
              }}
            >
              <h3 style={{ margin: 0, color: '#008080' }}>Generated VB6 Code</h3>
              <div>
                <button
                  onClick={generateCode}
                  style={{
                    padding: '4px 12px',
                    border: '1px outset #c0c0c0',
                    backgroundColor: 'white',
                    cursor: 'pointer',
                    fontSize: '8pt',
                    marginRight: '8px',
                  }}
                >
                  Refresh
                </button>
                <button
                  onClick={() => navigator.clipboard.writeText(generatedCode)}
                  style={{
                    padding: '4px 12px',
                    border: '1px outset #c0c0c0',
                    backgroundColor: 'white',
                    cursor: 'pointer',
                    fontSize: '8pt',
                  }}
                >
                  Copy to Clipboard
                </button>
              </div>
            </div>

            <textarea
              value={generatedCode}
              readOnly
              style={{
                width: '100%',
                height: '400px',
                fontFamily: 'Consolas, Monaco, monospace',
                fontSize: '9pt',
                border: '1px inset #c0c0c0',
                padding: '8px',
                backgroundColor: '#fafafa',
                whiteSpace: 'pre',
                overflow: 'auto',
              }}
            />
          </div>
        )}
      </div>

      {/* Property Designer Modal */}
      {showPropertyDesigner && (
        <PropertyDesigner
          property={editingProperty}
          onSave={saveProperty}
          onCancel={() => {
            setShowPropertyDesigner(false);
            setEditingProperty(undefined);
          }}
          existingNames={existingPropertyNames.filter(name => name !== editingProperty?.name)}
        />
      )}

      {/* Method Designer Modal */}
      {showMethodDesigner && (
        <MethodDesigner
          method={editingMethod}
          onSave={saveMethod}
          onCancel={() => {
            setShowMethodDesigner(false);
            setEditingMethod(undefined);
          }}
          existingNames={existingMethodNames.filter(name => name !== editingMethod?.name)}
        />
      )}
    </div>
  );
};

export default ClassBuilder;
